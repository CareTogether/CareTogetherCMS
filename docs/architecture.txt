| "Glossary"
UseCase Glossary {
@@@
# Glossary
The following terms need to be understood and used consistently throughout both the CareTogether organization and platform.

## Voice
These terms capture the "brand voice" of CareTogether. They MUST be used only with the exact meanings that they are given here.

- **Relational** - an approach to human services that emphasizes transformation via relationships, as opposed to a merely *transactional* approach that often fails to achieve lasting change. See [The Rise of Antipoverty Relational Work
(Stanford Social Innovation Review, 2015)](https://ssir.org/articles/entry/the_rise_of_antipoverty_relational_work).

## Who?
- **Organizations** are human services organizations. Organizations can be formally or informally organized. Formal organizations include both nonprofit and for-profit private-sector organizations as well as government organizations.
- **Locations** are geographically focused areas in which a specific group of people within an organization serve clients (perhaps under more than one program). Locations do not have a strict definition, but they are best defined by travel time, i.e., they should be small enough that the people who serve the clients within that location can physically interact. For example, two cities (or counties, or parts of a larger metropolitan area) that are separated by more than an hour or two of travel time should typically be separate locations. A _case_ is always tied to a single location.
- **Programs** are the actual services, comprised of policies and procedures, that an organization offers to its clients. The mapping between locations and programs is N-to-M: multiple programs within the same location can serve the same clients, and an organization may not offer the same programs at all of its locations. Program policies and procedures can vary by location.
- **Networks** are assocations of organizations, with various types of relationships established between them. For example, one organization may be a referral partner for another; referrals may flow in one direction or both between them. Other organizations (e.g., churches) may themselves represent communities of people who are helping within a program of another organization. There are also networks of networks, at several layers: a local ministry might have a network of partner churches for which they maintain records & processes in a program context, then that local ministry might participate in an area-wide referral partnership and support network, and then that area network might be part of a regional/national/international network sharing best practices and larger-scale resources (e.g., to offer capabilities like self-insurance for network members). A network can have subsets (which may not be isolated from each other but may share a common focus), e.g. an interest network or affinity network within ForCLT.
- Policies
- Procedures
- **Person** - any human being, about which we can store certain facts (name, contact info, etc.)
- **Family** -- sort of a fiction/loose concept (important to treat it as a dimension, perhaps, at a minimum) -- we already identify families by their primary contact
  - Record-keeping scope *may* vary by organization?
  - Reality of families is that they are a very nebulous concept, especially for many client families
- **Household** -- has some implications for approval rules, e.g. background checks for all household members is a policy
  - When people *leave a household* that's typically the trigger for the actual business activity of moving them to another family "entity" today in V1.
- "Contact" - someone from another organization who is tracked in the system, e.g. as a referral source
- Staff
  - Organizational function? Make this configurable? -- would be helpful to be explicit, and manually adjustable, re: which function(s) a person/family is
  - "organizational functions" apply to people (persons), but not necessarily to families: a family can be a volunteer family, can be a client family, but cannot be a staff family.
  - Families vs. households: need to revisit how we do recordkeeping around these overlapping concepts
- **Helpers** - people who are serving other people are called 'helpers' to be sufficiently general. Helpers may be volunteers or (paid or unpaid) staff. Note that unpaid staff have a more formal association with an organization than 'volunteers'. "Helpers" represent the counterpart to "Clients".
- **Clients** - Unfortunately in the IDesign Method, and software architecture generally, the term 'Client' is used for a specific technical purpose that is unrelated to this idea of a **program participant**, someone who is receiving the services offered by an HSO. However, the term **client** is the predominant (universally accepted) term in the human services sector. Thus, when talking about the _domain_, we refer to **clients**.
- Referral Partner - another HSO that agrees to receive outbound referrals made by an HSO and/or provides inbound referrals to an HSO

## What?

- **Membership** of organizations, staff, volunteers, and participants
- **Processes** for following the organization's policies and procedures
- **Communication** with staff, volunteers, participants, and referral partners

## How?


## Where?

Human Services - official definition? Do we narrow this?

Platform

System

Case -- NOTE: The term 'Need' may be more appropriate, especially at other levels of the fractal.

Case Management

Referral

Approval

Role

Arrangement

(Referral, Case, Arrangement) Function

(Function) Assignment

Community

Community Members

@@@
}

|
| "Purpose"
UseCase Purpose {
@@@
# Purpose
The following fundamental statements define and guide both the CareTogether organization and platform.

## Mission

To make human services more relational.

## Objectives

1. Minimize the risk of platform-level as well as organization-level data breaches for all customers, while mitigating the impact of individual-level user account takeovers.
2. Ensure system resilience, including providing for long-term support and maintenance.
3. Help customers establish and maintain regulatory compliance.
4. Help customers optimize their processes and communications.
5. Allow even the smallest human services organizations to fully adopt the system.
6. Enable even the largest human services organizations to fully embrace the platform, including qualifying for relevant grants.
7. Build a network of partnering human services organizations that can provide wrap-around support to participants in a geographic area.
8. Empower partners and AI agents to fully leverage the platform.
9. Provide the highest quality user experience in the industry for all users.
10. Build the capacity to serve the ~300,000 human services organizations in the United States and support global use.
11. Enable longitudinal studies of human services outcomes and impact in order to identify and share best practices with organizations.
12. Provide an avenue for self-insurance.
13. Assist organizations in networking based on insights into relevant potential partners.
14. Empower clients to maintain effective control of their personal data.

## Vision

Develop a case management platform that reimagines connection for human services.

@@@
}

|
| "Operational Concepts & Observations"

|
| "Use Case Family: Process"
/* The 'helping' use case family encompasses the actual services being provided to
   clients, which requires defining and evaluating policies,
   as well as procedures (workflows) for recordkeeping and oversight. */


Activity "Invite Person" {}
Activity "Accept Person Invitation" {}
Activity "Link New Login to Person" {}
Activity "Review Person Logins" {}



/* Facet: Organization Records */
Activity "Configure Organization" {} /* Core use case: includes authn, locations, programs, roles */
Activity "Configure Process" {} /* Core use case: includes policies, procedures, forms */



/* There is a symmetry between the need vetting (intake) process and the sign-up
   vetting (approval) process. */

Activity "Request to Serve" {
  |Client|
  start
  :Submit request;
  |System|
  :Validate request;
  if (Request valid?) then (no)
    |Client|
    :Error;
    stop
  else (yes)
    |System|
    :Publish request;
    stop
  endif
}

UseCase "Apply to Serve" {
  WebAppClient - IProcessManager.SubmitRequest() > ProcessManager
  ProcessManager - IEvaluationEngine.ValidateRequest() > EvaluationEngine
  EvaluationEngine - IConfigurationAccess.LoadPolicy() > ConfigurationAccess -> ConfigurationResource
  ProcessManager - IPubSubUtility.Publish() > PubSubUtility
}

Activity "Apply for Membership - Person to Organization" {
  |Client|
  start
  :Submit request;
  |System|
  :Validate request;
  if (Request valid?) then (no)
    |Client|
    :Error;
    stop
  else (yes)
    |System|
    :Publish request;
    stop
  endif
} /*TODO:
    This is a tricky problem to resolve for our fractal, if it is one?
    The problem of a 'household of one' arises when a person then has to be in
    two or more different 'households', e.g. once as a family coach and once as
    a parent in a host family. The person is trying to participate both as a
    family coach and as a host parent. The host parent participation is easy to
    model as a household, because everyone in the household is participating in
    serving as a host family (with possible exceptions, e.g. adult children
    living at home). The family coach approval rules are all individual; the
    host family approval rules are a combination of individual and family level.
*/

/*TODO: Eventually need to discuss invitations, discovery, etc. */

/* The system deals with policies and procedures in the Process Manager.
   Policies are system-enforced invariants (although users can exempt policy requirements with the right permissions),
   and so policy *evaluation* is handled by the EvaluationEngine. This logic exists in V1 today. A future rewrite may implement a DSL here.
   For now, the 'EvaluateApproval' activity for the approval policy is just an activity in the Elsa workflow.

   Our first pass is that every Elsa activity should be an operation on a SoEx service. Later on we can introduce composite activities.

   Procedures are freeform drag-and-drop workflows that hook into the invariant elements of the system,
   from a ready-made closed set of activities, e.g.,
   an 'Approval Procedure' will need to be defined per "tenant" (possibly more granular, e.g. varying by program). */

/* This use case is for configuring a policy (whether a true DSL or not) */
UseCase "Configure Membership Approval Policy" {
  WebAppClient - ConfigurePolicy(ApprovalPolicy) > ProcessManager
  /*TODO: Validate the policy */
  ProcessManager - Store(ApprovalPolicy) > ConfigurationAccess -> ConfigurationResource
}

/* For now, this could be done out-of-band using Elsa Studio behind the scenes.
   In the future, this needs to be integrated into the WebAppClient and the ProcessManager needs to orchestrate the use case. */
UseCase "Configure Membership Approval Procedure" {
  SupportClient - Edit(WorkflowDefinition) > WorkflowUtility
}

UseCase "Apply for Membership - Person to Organization" {
  /* MembershipApplication is applicable to both volunteer applications (organization level), membership applications (area network), membership applications (regional network)... */
  WebAppClient - WorkflowInstance IProcessManager.SubmitRequest(MembershipApplication) > ProcessManager
  /* The workflow stores the sequence/flowchart of actions to take in the helper approval process. */
  /*BLAIR: IMembershipSomething etc. breaks the parser */
  /* The approval process starts with a membership application. It ends with an approval decision. */
  ProcessManager - WorkflowInstance IWorkflowUtility.Approve(MembershipApplication) > WorkflowUtility

  /*TODO: How do we represent to the user "what is left to do" -- i.e., the full past & future of the workflow?
          What actions are past-due, which ones were exempted, etc.
          And subject to access levels (who can see certain actions)...
          Part of the steps in the workflow update the UI -- send XAML etc. -- or fire events,
          have clients monitor the events. ---> all async via queues */
}

DTO WorkflowInstanceId {} /* GUID value type */

DTO WorkflowInstance {
  WorkflowInstanceId Id
  WorkflowState State
}

UseCase "Validate Membership Application" {
  ProcessManager - IEvaluationEngine.Validate(MembershipApplication) > EvaluationEngine
  EvaluationEngine - Policy IConfigurationAccess.LoadPolicy() > ConfigurationAccess -> ConfigurationResource
}

UseCase "Validate Referral Request" {
  ProcessManager - IEvaluationEngine.Validate(ReferralRequest) > EvaluationEngine
  EvaluationEngine - Policy IConfigurationAccess.LoadPolicy() > ConfigurationAccess -> ConfigurationResource
}

UseCase "Evaluate Approval Policy" {
  /* The workflow can decide, based on the ApprovalResult ('outcome' in Elsa terms), what to do next. */
  ProcessManager - ApprovalResult IEvaluationEngine.Review(MembershipApplication) > EvaluationEngine
  EvaluationEngine - Policy IConfigurationAccess.LoadPolicy() > ConfigurationAccess -> ConfigurationResource
  /* Fancy internal algorithm runs here */
  EvaluationEngine - IRecordsAccess.Store(ApprovalResult) > RecordsAccess -> RecordsResource
}

UseCase "Publish Membership Application Approval Request" {
  ProcessManager - IMembershipEvent.OnApplicationReceived(MembershipApplication) > PubSubUtility
  /* The PubSubUtility will pass this to its subscribers. Subscribers *also* implement IMembershipEvents */
}

/* PWCF: Transient subscribers vs. persistent subscribers... */
/* Subscription management application... -- in domain-informed terms */

UseCase "Configure Membership Application Approval Request Subscription" {
  /*BLAIR: 'IMembershipEventPublisher' is not allowed? */
  SupportClient - IPublishMembershipEvent.AddMembershipApplicationApprover(ApproverParameters) > PubSubUtility
}

UseCase "Receive Membership Application Approval Request" {
  /* The implementation of this will send the email that based on the channel */
  PubSubUtility - IMembershipEvent.OnApplicationReceived(MembershipApplication) > EmailAccess
}

/*TODO: How do we notify potential approvers that there is something to approve?
        We need to post an event... */

/*TODO: This is an example, needs to be refined further */
UseCase "Approve Membership Application Document" {
  WebAppClient -> ProcessManager
  ProcessManager - WorkflowState IWorkflowsAccess.ResumeWorkflow(ResumeParameters) > WorkflowUtility
}

DTO ResumeParameters {
  WorkflowInstanceId Id /* The specific workflow instance to resume */
  ActivityId ActivityId /* The activity that was completed by the user/system client. */
  /*TODO: Need to source-generate the known types for this */
  T Parameters /* The DTO representing the values to provide */
}


UseCase "Check Application Status" {
  @@@
  Could be via polling or the first time you sign into the web app in a new browser, or both.
  @@@
  WebAppClient - MyWorkflows CheckStatus() > ProcessManager
  ProcessManager - MyWorkflows CheckStatus() > EvaluationEngine
  /* UserCriteria can include interval, status, etc. */
  EvaluationEngine - InterrogateWorkflows(UserCriteria) > WorkflowUtility
  /* TODO: Apply access level disclosure logic */
  /* NOTE: In the future, we could apply prioritization logic based on severity, dependencies, compliance, etc. */
}


UseCase "Alter Policies & Procedures" {
  /* We need to compile domain-specific procedures into workflow definitions. Here, we do this on the fly.
     We could alternatively do this only whenever the policy/procedure is altered. */
  ProcessManager - IEvaluationEngine.CompileProcedure() > EvaluationEngine
  EvaluationEngine - IConfigurationAccess.LoadProcedure() > ConfigurationAccess -> ConfigurationResource
}


Activity "Begin (membership) vetting ('helper approval') process" {
  |System|
  start
  :Receive request;
  :Create helper approval;
  :Determine vetting actions;
  note: Start workflow?;
  :Store helper approval actions;
  :Publish helper approval started;
}

UseCase "Begin (membership) vetting ('helper approval') process" {
  /* Reference: PubSub utility appendix in PWCF */
  PubSubUtility - IProcessManager.OnMemberApplied() > ProcessManager

}


/* NOTE: When to notify different people/groups in the organization should be part of the workflow. */
Activity "Notify helper approval supervisors" {
  |System|
  start
  :Receive helper approval started;
  :Lookup helper approval supervisors;
  |Helper|
  :Notify helper approval supervisors;
}

Activity "Complete a helper approval action" {
  |Helper|
  start
  :Complete action;
  |System|
  :Record action completion;
  :Process workflow;
}




Activity "Create Referral" {
  |Client|
  start
  :Submit referral request;
  note: Referral can be linked to a client household.
  |System|
  :Validate referral request;
  if (Request valid?) then (no)
    |Client|
    :Error;
    stop
  else (yes)
    |System|
    :Create referral;
    :Determine intake steps;
    :Store intake steps;
    :Publish referral created;
    stop
  endif
}

UseCase "Create Referral" {
  @@@
  ### Actor(s)
  User identity or Organization identity.
  
  ### Operational Concept
  The system:
  1. validates the caller's account,
  2. 

  ### API
  `POST /referrals/{referralId}`
  
  ### Test Cases
  1. **Given** ...,
     **when** requesting help **then** ...
  2. **Given** the referral request is invalid,
     **when** requesting help **then** an opaque fault is returned.
  @@@
  WebAppClient - Referral SubmitRequest(ReferralRequest) > ProcessManager
  ProcessManager - void Validate(ReferralRequest) > EvaluationEngine
  ProcessManager - Referral CreateReferral(ReferralRequest) > RecordsAccess -> RecordsResource
  ProcessManager - IntakeSteps DetermineIntakeSteps(Referral) > EvaluationEngine
  EvaluationEngine - IntakePolicy LookupIntakePolicy() > ConfigurationAccess -> ConfigurationResource
  ProcessManager - SaveIntakeSteps(IntakeSteps) > RecordsAccess -> RecordsResource
  ProcessManager - IProcessEvent.OnReferralCreated(Referral) > PubSubUtility
}

UseCase "Custom procedure when a referral is created" {
  @@@
  This is an example of a custom procedure "hook" that the system exposes.
  @@@
  PubSubUtility - IProcessEvent.OnReferralCreated(Referral) > WorkflowUtility
}

/* TODO: This feels like it's just pub/sub and not a dedicated usecase. */
Activity "Notify intake supervisors" {
  |System|
  start
  :Receive referral created;
  :Lookup intake supervisors;
  |Helper|
  :Notify intake supervisors;
}

UseCase "Notify intake supervisors" {
  PubSubUtility - IProcessEvent.OnReferralCreated(Referral) > CommunicationManager
  CommunicationManager - CommunicationPolicy LookupCommunicationPolicy() > ConfigurationAccess -> ConfigurationResource
  /*TODO: This is not great */
  CommunicationManager - Send(Message) > PubSubUtility
}

/* Scheduling process (who/what) assigns Helpers to handle intake. */
Activity "Complete an intake action" {
  |Helper|
  start
  :Complete action;
  |System|
  :Record action completion;
  :Process workflow;
  
}
/*
Activity "Configure Intake Supervisor" {
  |Helper|
  start
  :Subscribe to 'intake started';
}*/


/*SYMMETRY: Requests --> Processes --> Actions */

Activity "Onboard a New Member" {}



Activity "Open Case" {}

Activity "Close Case" {}



Activity "Set Up Arrangement" {}

Activity "Complete Setup Action" {}

Activity "Cancel Arrangement" {}

Activity "Start Arrangement" {}

Activity "Monitor Arrangement" {} /* TODO: Not sure about naming here */

Activity "Complete Monitoring Action" {}

Activity "Track Child Location" {} /* *VERY* specific element in the domain, not fractal-friendly */
/* We can imagine that other human services categories will have other domain-specific "things",
   e.g. Track Occupancy in transitional living --- this feels like 'industry' context? */

Activity "Close Out Arrangement" {}

Activity "Complete Closeout Action" {}

Activity "Follow Up With Client" {}





Activity "Help Client" {}
Activity "Apply to Help" {}
Activity "Recruit Helpers" {}
Activity "Helper Approval" {}
Activity "Establish Referral Partner" {}
Activity "Make Outbound Referral" {}
Activity "Assess Impact" {}

Activity "Client Referral Intake" {
  start
  stop
}






/* NOTE: The following are *operations* -- activities */
Activity "Submit Records" {} /* Core use case; includes archiving records, managing user roles */
Activity "Retrieve Records" {} /* Core use case */

Activity "Approve Records Submission" {}
Activity "Reject Records Submission" {}
Activity "Approve Records Retrieval" {}
Activity "Reject Records Retrieval" {}

Activity "Download Document" {}
Activity "Upload Document" {}

/* Post-2025/2026 */
/* There may be a fractal here? */
Activity "Accept Inbound Referral" {}
Activity "Submit Outbound Referral" {}

/* Facet: Personal Records */
/* Is a household an organization if we squint enough? Maybe. */
/* Is an organization a person, if we squint enough? Maybe. */
Activity "Upload Requested Documentation" {}
Activity "Generate Assertions" {}
Activity "Share Assertions" {}
Activity "Audit Assertions" {}

|
| "Core Use Case: Communication"
/* For symmetry: organization & personal facets? */
/*TODO: This section still needs to be cleaned up */

Activity "Notify Organization" {}

Activity "Send Bulk SMS" {} /* This is a primitive action */
Activity "Volunteer Search" {} /* This is a -- very complicated -- workflow */
Activity "Communication Tree" {} /* This is a workflow */
Activity "Notify Person" {}
Activity "Broadcast" {} /* to an audience */
Activity "Receive Response" {} /* this is a placeholder */
Activity "Notify of Record Changes" {} /*TODO: Revisit what this part of the domain looks like abstractly */


|
| "Reference --- other services' responsibilities"

Activity "Query Permissions" {} /* Feels like an evaluation activity */
Activity "Calculate Approval Status" {} /* Feels like an evaluation activity */
Activity "Calculate Pending Steps" {} /* Feels like an evaluation activity */


|
| "Volatilities"

UseCase Volatilities {
@@@
## Volatilities

- XYZ
@@@
}


|
| "Static Aspect"
StaticAspect "CareTogether V2" {
  WebAppClient SupportClient SdkClient
  /* GraphQL/HTTP API layer */
  ProcessManager CommunicationManager AnalysisManager
  EvaluationEngine MatchingEngine
  NetworkAccess ConfigurationAccess RecordsAccess
  /*NOTE: NetworkResource? -- Cosmos DB Graph API & Cosmos DB 'SQL' API, allowing Geode pattern. */
  NetworkResource
  /*NOTE: Configuration includes the DSL 'procedures' which can be *compiled* into workflows. */
  ConfigurationResource:f
  /*NOTE: Audit logs are an aspect of record-keeping. */
  /* Notes are part of RecordsResource but stored w/ immutability enabled.
     Forms are part of RecordsResource. */
  RecordsResource
  SecurityUtility /* Includes account management operations */
  TelemetryUtility
  LoggingUtility
  PubSubUtility /* Push notifications to WebApp are allowed, as queued calls; can include delivery via SMS, WhatsApp, Telegram, Teams, Slack, etc. */
  /* User will subscribe to pub-sub endpoints; the CommunicationManager will generate channel-specific events in response to domain events */
  WorkflowUtility
}


|
| "Fractal Concepts"

UseCase "Fractal Musings" {
  @@@
  A fractal is self-similar, which implies that our business use cases need to be
  self-similar at each level of the proposed fractal if this is truly a fractal.
  The levels - and associated purposes - of the proposed fracal are:
   1. Household - household/family record management -- primarily a way to participate
                  in the next level up in the fractal (i.e., request help/appy to help w/ orgs)
   2. Organization - case/church management (applies to ministries and local churches)
   3. Area - network management (needs/referrals can be shared with other network members:
             churches, ministries, businesses)
   4. Region - meta-network management (cities could ask for programs/ministries that they lack)
   5. World - global management (this exists today within denominations and global ministries;
              might tackle issues like the 10/40 Window where the fewest Gospel-centered networks
              exist, in order to establish and promote regional networks there)
  The organizers of networks at each layer, as well as the members/participants of
  networks at each layer (both clients and helpers), are different.
  In a ministry, the network organizers are the ministry staff, and the members are clients,
  volunteers, etc. (helpers)., but also churches.
  In a city, the network organizers are the network staff, and the members are
  ministries, churches, businesses, etc.
  In a region, the members are city/area networks.
  We need to clarify all of these terms once we've definitely established the existence &
  need for the fractal concept, but for now, any use cases we examine should be looked at in
  the context of each of these proposed levels to see how they might play out.
  This also means that terms like "client", "helper", "partner church", etc., which originated
  from the 'case management' level of ministries' internal networks, are not necessarily
  appropriate at every level of the fractal.
  One term we need to avoid for the moment is "community", because 'community' is a distinct
  concept from each of these things. Community is the network of people that *a person* (or
  household) is in relationship with. That is not a "managed" network like these others are.
  Community is something that develops as a result of relationship building, but community,
  unlike these networks for providing care, does not have record-keeping, policies/procedures,
  etc. It's the *result* of the work, not the components/ingredients to, of human services.
  Like the EnergyNet: "be resilient" is the one use case. "Build community" is the one use case.

  Let's define some terms that can be level-agnostic (valid at every level of the fractal):
   - **Network** - Each level of the fractal involves a network:
     0. The atomic lowest-level unit is an individual (a person), which does not have any
        members (i.e., no network of its own).
     1. A household *has a* network of people. A household can be a member of any number of
        organizations' networks, whether as a client, helper (staff or volunteer), donor, etc.
        A household can maintain records on each household member, e.g., birth certificates,
        paystubs, notes, etc.
     2. An organization *has a* network of households. Not every household member needs to
        participate in the organization's program, but the household *itself* is a member of
        the organization's network. And, the organization can maintain records on each household
        *as well as* each member of those households, e.g., approval or intake steps, notes, etc.
        An organization can be a member of any number of area networks (though ideally there
        would just be one per city, but in reality most cities have fragmented networks today).
     3. An area *has a* network of organizations. The area can maintain membership records for
        each member organization, as well as notes etc., and financial contributions, but can
        also handle sharing of general need requests, support discovery of and establishment of
        referral partnerships, and determine when area-level needs require reaching out to a
        regional network.
     4. A region *has a* network of areas. (Handle insurance...)
     5. The world *has a* network of regions.

  The fly in the ointment here is that the details of child location tracking, for example, do
  *NOT* translate readily to every level of this proposed fractal. Therefore, we'll defer the
  fractal discussion for now. The organizational networking component may be the one aspect of
  CareTogether that does exhibit true fractal behavior.
  @@@
}


/* The 'networking' use case family captures the work of connecting organizations
   and people in ways that allow help to be offered. This can happen at multiple
   levels (networks of networks), which is where fractal behavior seems to emerge:
   the kinds of help and communication that occur at each level will be different,
   but the fundamental purpose of networks at each level remains the same: to help.*/


Activity "Discover Potential Referral Partners" {}

Activity "Establish Referral Partnership" {}

Activity "Invite Organization" {}

Activity "Accept Organization Invitation" {}

/* We want to eventually reach the point where an individual or household 'login' to
   CareTogether can be linked to multiple organizations with which that individual/household
   wants to work, e.g. to offer to help/volunteer for more than one organization. This in
   turn implies that the linking of household/individual "nodes" to organizations *is* a
   fractal relationship that can be optionally established. */

Activity "Recruit Member" {} /*TODO: Create an activity diagram here! */


/* Maybe it's part of Networking family instead of Helping, because the helping is not happening yet, but connecting/networking is. */
Activity "Find appropriate Partner for Case" {} 
Activity "Refer Case to Partner" {}

Activity "Share resource" {}
Activity "Govern network?" {} /* Is there some kind of governance in a network? */
Activity "Manage network member" {} /* Include or remove a member, update status, update attributes for matching? */


/*NOTE: We need some sort of process that determines if we need outside help, i.e.,
        if a new request for help needs to be issued upward or horizontally acrosss.
        Upward would be e.g. organization to area, across would be e.g. organization to
        organization (the classic "referral partner" model).
        Note that *downward* is simply the search for a helper as well.
        In every case, this involves a 'search' sequence (search down, search across,
        and finally search up -- note that some stages may be skipped based on the need).
        In other words, the basic behavior of each participant is that, when receiving a
        request for help, the participant will first ask downward to all the members of
        that participant's own network to see if a Helper can help. That may not always
        result in actually sending requests to the Helpers if e.g. none of the helpers
        fit the criteria for helping with the need, but it should be the first option.
        Then, the fractal participant will next consider any horizontal partnerships
        (relationships?) with other participants at the same fractal level; these are
        established sometimes outside of being part of a higher-level network. E.g.,
        an organization may forward the need to another organization that has established
        a referral partnership with the first organization. (NOTE: During the vetting
        process, it may be determined that a need is only a candidate for either internal
        or partner help, as opposed to both, e.g. if a request for help is received by a
        family preservation ministry but the need, after vetting, turns out to be for
        temporary housing.) As a last resort, a participant may pass a need *upward* to
        the network(s) it is a member of, i.e., outside of its own network or partners,
        to try to find a helper there. That is a much more rare situation, but is a
        necessary step when needs might be too great for the participant to meet alone.
        This "algorithm" (search down, then across, then up) is consistent at every level
        of the fractal.
*/

/*      Is helping a commodity? Are needs commodities?
        It's a spectrum -- some help is a commodity, some is highly specialized.
        Are we first addressing commodities or specialization?
        Specialization is all about whether someone is available.
        Over-the-counter transactions vs. market transactions?
        OTC transactions is how commodities markets deal with one-offs...
        ...
        Difference between transactive resource management (matching a need with a helper)
        and automatic transactive resource management.
        Pricing/valuation component is therefore not needed.
*/



/* CRITICAL: A participant can and usually will have more than one network.
             A corollary to this is that a participant will often be a *member* of
             more than one network as well.
             The fractal architecture allows for overlap here, so e.g. a person can
             be in a household as a participant of a ministry as a family coach, and
             can also be in a household as a participant of the same ministry as a
             host family.
             This still feels weird -- helpers who are family coaches are not usually
             (or ever) thought of as households, e.g. a therapist is not serving their
             client as a household but as a professional. This is still unresolved/
             needs more discussion. */

/*
Prospective 'members' (whether volunteers or organizations)
   can apply to join a 'network' (the set of members managed by a node in the fractal),
   and those applications then trigger a vetting process that the managing node is
   responsible for.
*/
|
| "Other DD"

/*
## Use Cases (Call Chains & Sequence Diagrams), Detailed Design
*/

/* OPERATION CONTRACTS -- WORK-IN-PROGRESS

ProcessManager
  - ConfigureOrganization
  - ConfigurePolicies // could end up just being part of ConfigureOrganization? maybe just call it 'Configure' & use polymorphism?
  - SubmitRecords // (un)archive is a special case that could just be a validation rule: 'IsActive' flag changes cannot be accompanied by other changes
    // SubmitRecords could actually update the record *or* decide to create a change request instead, based on policies
    // When a change request is issued, the ProcessManager makes a queued call to CommunicationManager to notify the record owner or other responsible party (as identified by policy evaluation) of the pending change.
  - RetrieveRecords
  - ReviewChanges

MembershipManager
  - InviteUser
  - RegisterAccount
  - CloseAccount
  - LinkAccount // links an account to a person in a location in an organization
  - FindAccount

CommunicationManager
  ...
  // The CommunicationManager has the ability to send email notifications as well as interactive notifications,
  // e.g. Teams adaptive cards, for things like change request approvals.

WorkflowsAccess
  - WorkflowState Instantiate(WorkflowCriteria) // 'run user-defined actions'?
  - WorkflowState Dispatch(InputEvent)

RecordsAccess
  - Create
  - Change
  - Filter
  - ProposeChange // add a new pending change to the underlying record's set of pending changes
  - CommitChange // needs to reference an existing pending change
  - CancelChange // needs to reference an existing pending change
    // Records include: Families, Communities, Organizations
    // Organizations could themselves be using CareTogether, allowing features like automatic transfer of intake data

// Records need to include a set of 'pending changes', each of which has a 'RequestedChangeId' that is tied to the request workflow.
// Pending changes should be stored in non-immutable storage, like draft notes are today, and only the reference to them should be
//   made part of the immutable log.

ConfigurationAccess
  ...

AccountsAccess
  ...

AuditAccess
  ...

*/

/*
QUESTION: What are we storing/exposing with RecordsAccess?

Option 1: only specific "Aggregates" as defined today: Families, Communities, Referrals, eventually Organizations.
>>> This feels the most consistently organized.

Option 2: all "Entities" in the domain model: Families, People, Referrals, Cases, Arrangements, Communities, Organizations.
This would actually also need to include:
- Requirement Completions/Exemptions
- Child Location Changes (Actual & Planned)
- Function Assignments
- Notes
- Documents (reference to them)
- Forms (reference to them)
- Organization Members
- Organization Roles

--> This approach basically exposes a relational database!

SMELL: This is fine-grained, not coarse-grained. We want to encapsulate the variability of different types of records.
SMELL: How do you define a 'pending change' to a requirement completion? What would be an example? On the other hand, it feels very reasonable to make a 'pending change' to a *family* (or maybe a person or arrangement or referral or case?) of a requirement completion, e.g. a family coach submitting a safety visit completion. Therefore, treating a Requirement Completion *as a record* is too granular. Therefore, we need some level of combining these "entities" into "aggregates" that are reasonable to modify.

Option 3?

Option 4: The entire dataset for a location? Waaaaay too coarse-grained. Writes need to be made at a more granular level.

*/

/*
# MIGRATION NOTES
- Authorize*CommandAsync methods move into the Resource Access layer (primarily into RecordsAccess)
*/

Activity "UC-Me-1: Sign In" {
  |u|User
  |s|System
  |u|
  start
  :Browse to CareTogether;
  if (User signed in) is (no) then
    :Redirect to Sign-In Screen;
    |s|
    :Determine sign-in methods to offer;
    |u|
    :Select sign-in method;
    :Enter credentials;
    |s|
    :Load user account;
  else (yes)
  end if
  |u|
  :Open Dashboard;
  stop
}

/* TODO: review */
UseCase "UC-Me-1: Sign In" {
  WebClient - ClaimsPrincipal ISecurityUtility.Authenticate(HttpContext) > SecurityUtility
  WebClient - AppUserAccount IMembershipManager.SignIn(ClaimsPrincipal) > MembershipManager
  MembershipManager - Account IAccountsAccess.GetOrCreateUserAccount(ClaimsPrincipal) > AccountsAccess
  AccountsAccess -> AccountsResource /*  Account IAccountsResource.GetOrCreateUserAccount(UserId) */
  AccountsAccess -> RecordsResource
}

/* HttpContext DTO is provided by ASP.NET Core */
/* ClaimsPrincipal DTO is provided by System.Security.Claims */

DTO AppUserAccount {
  Guid UserId
  /*TODO: Define this*/
}

DTO Account {
  Guid UserId
  AccountOrganizationAccess[] Organizations
}

DTO AccountOrganizationAccess {
  Guid OrganizationId
  AccountLocationAccess[] Locations
}

DTO AccountLocationAccess {
  Guid LocationId
  Guid PersonId
  string[] Roles
}

Activity "UC-Pr-1: Open Location" {
  |c|Client
  |s|System
  |c|
  start
  :Sign In
    ""<color:#777>[UC-Me-1]</color>"";
  :Select Organization;
  :Select Location;
  |s|
  :Authorize User Access in Context
    ""<color:#777>[SUB-Pr-1]</color>"";
  :Load Location Data; 
  'NOTE: This will also be the Process Manager
  |c|
  :View Location Dashboard;
  stop
}

UseCase "UC-Pr-1: Open Location" {
  WebClient -> ProcessManager
  ProcessManager -> EvaluationEngine
}

UseCase "SUB-Pr-1: Authorize User Access in Context" {
  ProcessManager - ContextPermissions IEvaluationEngine.AuthorizeUserAccess(AuthorizationContext) > EvaluationEngine
    EvaluationEngine -> AccountsAccess -> AccountsResource
    EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    EvaluationEngine -> RecordsAccess -> RecordsResource
  ProcessManager -> SecurityUtility
}

DTO AuthorizationContext { }

/*BUG: DTO inheritance is not supported*/
/*DTO GlobalAuthorizationContext : AuthorizationContext {}*/

UseCase "Retrieve Records" {
  WebClient - RetrieveRecordsResponse IProcessManager.RetrieveRecords(RetrieveRecordsRequest) > ProcessManager
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager - RecordsResponse IRecordsAccess.Filter(RecordsCriteria) > RecordsAccess
      RecordsAccess -> RecordsResource
      RecordsAccess -> NotesResource
      RecordsAccess -> FormsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager - RecordsResponse IEvaluationEngine.DiscloseRecords(RecordsDisclosureRequest) > EvaluationEngine
    /* Include disclosure & authorization results */
    ProcessManager -> AuditAccess -> AuditResource
}

DTO RetrieveRecordsRequest {
  DisclosureMethod Method
  RecordType? RecordType
  Guid? OrganizationId
  Guid? LocationId
  Filters? Filters
}

DTO Filters { }

DTO RetrieveRecordsResponse {
  Community[] Communities
  Family[] Families
  Organization[] Organizations
}

DTO Family {
  Guid Id
  Guid LocationId
  string Name
  string? PrimaryEmail
  string? PrimaryPhoneNumber
  Address? PrimaryAddress
  string? HomeChurch
}

DTO Address {
  string? Line1
  string? Line2
  string? City
  string? Country
  string? State
  string? PostalCode
}

DTO Community {
    Guid Id
    Guid LocationId
    string Name
}

DTO Organization {}

DTO ContextualPermissions {
  AuthorizationContext Context
  string[] AllowedActions
  Account Account
}

DTO RecordsDisclosureRequest {
  ContextualPermissions Permissions
  DisclosureMethod Method
  RecordsAccess.RecordsResponse Records
}

DTO RecordsCriteria {
  ContextualPermissions Permissions
  DisclosureMethod Method
  RecordType? RecordType
  Guid? OrganizationId
  Guid? LocationId
}

DTO RecordsResponse {
  Community[] Communities
  Family[] Families
  Organization[] Organizations
}

UseCase "UC-Pr-6: Submit Recods (create or change)" {
  WebClient - SubmitRecordsResponse IProcessManager.SubmitRecords(SubmitRecordsRequest) > ProcessManager
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager - RecordOperationsResponse IRecordsAccess.Execute(RecordOperationsRequest) > RecordsAccess
      RecordsAccess -> RecordsResource
      RecordsAccess -> NotesResource
      RecordsAccess -> FormsResource
      /*RecordsAccess -> DocumentsResource*/
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager - RecordsResponse IEvaluationEngine.DiscloseRecords(RecordsDisclosureRequest) > EvaluationEngine
    ProcessManager -:q> CommunicationManager
    ProcessManager -> AuditAccess -> AuditResource
}

DTO RecordOperation { } /* This can inclue create/change/propose change/commit change/cancel change */

DTO RecordOperationsRequest {
    ClaimsPrincipal 
    RecordOperation[] Operations
}

DTO SubmitRecordsRequest {
    Record[] Records
}


DTO Record {
  Guid Id
}

DTO RecordOperationsResponse {
    Record[] Records
}

DTO SubmitRecordsResponse {
    Record[] Records
}

/* TODO: check */
UseCase "UC-Pr-34: Discard Draft Notes" {
  WebClient - IProcessManager.ReviewChanges() > ProcessManager
  ProcessManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  ProcessManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
}

/* TODO: check */
UseCase "UC-Pr-35: Approve Notes" {
  WebClient - IProcessManager.ReviewChanges() > ProcessManager
  ProcessManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  ProcessManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
}

/* TODO: check */
UseCase "UC-Me-1: Invite Person User" {
  WebClient - IMembershipManager.InviteUser() > MembershipManager
  MembershipManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  MembershipManager -> AccountsAccess -> AccountsResource
}

/* TODO: account or records? */
UseCase "UC-Me-2: Edit Person User Protected Roles" {
  WebClient - IMembershipManager.ChangePersonRoles() > MembershipManager
  MembershipManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  MembershipManager - IAccountsAccess.Execute() > AccountsAccess -> AccountsResource
}

/* TODO: check */
UseCase "UC-Me-4: View Person User Login Info" {
  /* Feel like it should be similar to IProcessManager.RetrieveRecords()? */
  WebClient - IMembershipManager.FindAccount() > MembershipManager
  MembershipManager - IAccountsAccess.Filter() > AccountsAccess -> AccountsResource
  MembershipManager - IRecordsAccess.Filter() > RecordsAccess -> RecordsResource
  MembershipManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  MembershipManager - ISecurityUtility.GetUserLoginInfo() > SecurityUtility
}

UseCase "UC-Me-5: Edit Roles" {
  WebClient - IMembershipManager.ChangePersonRoles() > MembershipManager
  MembershipManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  MembershipManager - IAccountsAccess.Execute() > AccountsAccess -> AccountsResource
}

/* TODO: check */
UseCase "UC-Pr-76: Send Bulk SMS" {
  WebClient - ICommunicationManager.Notify() > CommunicationManager
  CommunicationManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  CommunicationManager - IRecordsAccess.Filter() > RecordsAccess -> RecordsResource
  CommunicationManager - ITelephonyUtility.Notify() > TelephonyUtility
}

DTO OpenCaseResponse {}

DTO OpenCaseRequest {}

/* ================== 1. Other use cases ================== */

/* ================== 1.1 RetrieveRecords Permutations ================== */

Activity "UC-Pr-2: View Communities List" {
  |c|Client
  |s|System
  |c|
  start
  :Open Location
    ""<color:#777>[UC-Pr-1]</color>"";
  :Select Communities Screen;
  |s|
  :List Communities for User;
  |c|
  :Display Communities List;
  stop
}

UseCase "View Communities List" {
@@@
### Prerequisites
- `ContextPermissions` for 'All Communities' context
@@@
  WebClient - IProcessManager.RetrieveRecords() > ProcessManager
    ProcessManager - IRecordsAccess.Filter() > RecordsAccess
      RecordsAccess -> SecurityUtility
      RecordsAccess -> RecordsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> EvaluationEngine
}

/* TODO: Missing FileStorageUtility? */
UseCase "UC-Pr-18: Read Family Documents" {
  WebClient - IProcessManager.RetrieveRecords() > ProcessManager
    ProcessManager - IRecordsAccess.Filter() > 
      RecordsAccess -> SecurityUtility
      RecordsAccess -> RecordsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> EvaluationEngine
}

/* TODO: check */
UseCase "UC-Pr-23: Access Settings Screen" {
  WebClient - IProcessManager.RetrieveRecords() > ProcessManager
    ProcessManager - IRecordsAccess.Filter() > 
      RecordsAccess -> SecurityUtility
      RecordsAccess -> RecordsResource
      RecordsAccess -> ConfigurationResource
      RecordsAccess -> AccountsResource
      RecordsAccess -> FormsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> EvaluationEngine
}

/* ================== 1.2 SubmitRecords Permutations ================== */

UseCase "Track Child Location" {
  WebClient - CreateChildLocationEntryResponse IProcessManager.SubmitRecords(TrackChildLocationChange) > ProcessManager
    ProcessManager - StoreChildLocationEntryResponse IRecordsAccess.Execute(ChildLocationEntry) > RecordsAccess 
      RecordsAccess -> SecurityUtility
      RecordsAccess -> RecordsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> EvaluationEngine
}

DTO CreateChildLocationEntryResponse { }

DTO TrackChildLocationChange {
    Guid FamilyId
    Guid ReferralId
    Guid[] ArrangementIds
    DateTime ChangedAtUtc
    Guid ChildLocationFamilyId
    Guid ChildLocationReceivingAdultId
    ChildLocationPlan Plan
    Guid? NoteId
}

DTO StoreChildLocationEntryResponse { }

DTO ChildLocationEntry {
    Guid ArrangementId
    Guid ChildPersonId
    Guid FamilyId
    DateTime StartedAtUtc
    ChildLocationPlan ChildcarePlan
    DateTime? EnededAtUtc
    TimeSpan Duration
}

UseCase "UC-Pr-19: Upload Family Documents" {
  WebClient - IProcessManager.SubmitRecords() > ProcessManager
    ProcessManager - IRecordsAccess.Execute() > 
      RecordsAccess -> SecurityUtility
      RecordsAccess -> RecordsResource /* TODO: Do we store a reference for the file? Should it be done after calling FileStoreUtility? */
      RecordsAccess - IFileStoreUtility.Upload() > FileStoreUtility
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> EvaluationEngine
}

UseCase "UC-Pr-20: Archive Family Documents" {
  WebClient - IProcessManager.SubmitRecords() > ProcessManager
    ProcessManager - IRecordsAccess.Execute() > 
      RecordsAccess -> SecurityUtility
      RecordsAccess -> RecordsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> EvaluationEngine
}

/* TODO: check */
UseCase "UC-Pr-64: Upload Community Documents" {
  WebClient - IProcessManager.SubmitRecords() > ProcessManager
  ProcessManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  ProcessManager - IFileStoreUtility.Upload() > FileStoreUtility
  ProcessManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
}

UseCase "UC-Pr-81: Open Case" {
  WebClient - OpenCaseResponse IProcessManager.SubmitRecords(OpenCaseRequest) > ProcessManager
  ProcessManager - IEvaluationEngine.AuthorizeUserAccess() > EvaluationEngine
  EvaluationEngine -> AccountsAccess -> AccountsResource
  EvaluationEngine -> RecordsAccess -> RecordsResource
  EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
  ProcessManager - IWorkflowsAccess.Instantiate() > WorkflowsAccess -> WorkflowsResource
  ProcessManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
  ProcessManager - ICommunicationManager.Notify():q> CommunicationManager
}

UseCase "Open Referral" {
  WebClient - OpenCaseResponse IProcessManager.SubmitRecords() > ProcessManager
  ProcessManager - IEvaluationEngine.AuthorizeUserAccess() > EvaluationEngine
  EvaluationEngine -> AccountsAccess -> AccountsResource
  EvaluationEngine -> RecordsAccess -> RecordsResource
  EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
  ProcessManager - IWorkflowsAccess.Instantiate() > WorkflowsAccess -> WorkflowsResource
  ProcessManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
  ProcessManager - ICommunicationManager.Notify():q> CommunicationManager
}

/* ================== 2. Other Data Models ================== */

DTO CreateReferral /* : RecordOperation */ {
    string Comments
    Guid? FamilyId
}

DTO Referral /* : Record */ {
    string Comments
    Guid? FamilyId
}

DTO CreateArrangementResponse { }

DTO CreateArrangementRequest { }

DTO StoreArrangementEntryResponse { }

DTO ArrangementEntry {
    Guid Id
    string ArrangementType
    bool Active
    DateTime RequestedAtUtc
    DateTime? StartedAtUtc
    DateTime? EndedAtUtc
    DateTime? CancelledAtUtc
    DateTime? PlannedStartUtc
    DateTime? PlannedEndUtc
    Guid PartneringFamilyPersonId
    ImmutableList<CompletedRequirementInfo> CompletedRequirements
    ImmutableList<ExemptedRequirementInfo> ExemptedRequirements
    ImmutableList<IndividualVolunteerAssignment> IndividualVolunteerAssignments
    ImmutableList<FamilyVolunteerAssignment> FamilyVolunteerAssignments
    ImmutableSortedSet<ChildLocationHistoryEntry> ChildLocationHistory
    ImmutableSortedSet<ChildLocationHistoryEntry> ChildLocationPlan
    string? Comments
    string? Reason
}

DTO CompletedRequirementInfo {
    Guid UserId
    DateTime TimestampUtc
    Guid CompletedRequirementId
    string RequirementName
    DateTime CompletedAtUtc
    DateTime? ExpiresAtUtc
    Guid? UploadedDocumentId
    Guid? NoteId
}

DTO ExemptedRequirementInfo {
    Guid UserId
    DateTime TimestampUtc
    string RequirementName
    DateTime? DueDate
    string AdditionalComments
    DateTime? ExemptionExpiresAtUtc
}

DTO IndividualVolunteerAssignment {
    Guid FamilyId
    Guid PersonId
    string ArrangementFunction
    string? ArrangementFunctionVariant
    ImmutableList<CompletedRequirementInfo> CompletedRequirements
    ImmutableList<ExemptedRequirementInfo> ExemptedRequirements
}

DTO FamilyVolunteerAssignment {
    Guid FamilyId
    string ArrangementFunction
    string? ArrangementFunctionVariant
    ImmutableList<CompletedRequirementInfo> CompletedRequirements
    ImmutableList<ExemptedRequirementInfo> ExemptedRequirements
}

DTO ChildLocationHistoryEntry {
    Guid UserId
    DateTime TimestampUtc
    Guid ChildLocationFamilyId
    Guid ChildLocationReceivingAdultId
    ChildLocationPlan Plan
    Guid? NoteId
}

DTO CreateFamilyResponse { }

DTO CreateFamilyRequest { }

DTO StoreFamilyResponse { }

DTO RecordParameters { }

DTO FamilyRecordParameters /* : RecordParameters */ {
    Guid FamilyId
}

DTO AddFamilyMemberRequest {
  Person Person
  Guid FamilyId
  FamilyAdultRelationshipInfo RelationToFamily
}

DTO Person {
  Guid PersonId
  string FirstName
  string LastName
  Gender? Gender
  Age? Age
  string? Ethnicity
  ImmutableList<Address> Addresses
  Guid? CurrentAddressId
  ImmutableList<PhoneNumber> PhoneNumbers
  Guid? PreferredPhoneNumberId
  ImmutableList<EmailAddress> EmailAddresses
  Guid? PreferredEmailAddressId
  string? Concerns
  string? Notes
}

DTO AddPersonToFamily {
  Guid PersonId
  Guid FamilyId
  FamilyAdultRelationshipInfo RelationToFamily
}

DTO AddChildToFamily {
  Guid PersonId
  Guid FamilyId
  FamilyAdultRelationshipInfo RelationToFamily
}

DTO ArchivePersonRequest {
    Guid PersonId
}

DTO ArchivePersonCriteria {
    Guid PersonId
}

DTO ChangePersonFamilyRequest {
    Guid PersonId
    Guid OriginalFamilyId
    Guid TargetFamilyId
}

/* ====================================================== */

/* 
Example draft implementation of changing a referral record.

Example SubmitRecordsRequest (ProcessManager.SubmitRecords input):

[{
  "Change": {
      "Comments": "Test",
      "Discriminator": "UpdateReferralComments",
      "FamilyId": "11111111-1111-1111-1111-111111111111",
      "ReferralId": "22222222-2222-2222-2222-222222222222",
  },
}]

var recordOperationsRequest = [
  {
    "Change": {
        "Comments": "Test",
        "Discriminator": "UpdateReferralComments",
        "FamilyId": "11111111-1111-1111-1111-111111111111",
        "ReferralId": "22222222-2222-2222-2222-222222222222",
    },
  }
]

recordsAccess.Execute(recordOperationsRequest);

// Check user's permissions.

// Apply change.

// Store patched record and append change to log.

*/

UseCase "System requests approval for record change" {
  WebClient - SubmitRecordsResponse IProcessManager.SubmitRecords(SubmitRecordsRequest) > ProcessManager
    /* Sub-usecase "SUB-Pr-1: Authorize User Access in Context" */
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager - RecordOperationsResponse IRecordsAccess.Execute(RecordOperationsRequest) > RecordsAccess
      RecordsAccess -> RecordsResource
      RecordsAccess -> NotesResource
      RecordsAccess -> FormsResource
      /*RecordsAccess -> DocumentsResource*/
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager - RecordsResponse IEvaluationEngine.DiscloseRecords(RecordsDisclosureRequest) > EvaluationEngine
    ProcessManager -:q> CommunicationManager
    ProcessManager -> AuditAccess -> AuditResource
}

UseCase "User approves record change" {
  WebClient - SubmitRecordsResponse IProcessManager.SubmitRecords(SubmitRecordsRequest) > ProcessManager
    /* Sub-usecase "SUB-Pr-1: Authorize User Access in Context" */
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager - RecordOperationsResponse IRecordsAccess.Execute(RecordOperationsRequest) > RecordsAccess
      RecordsAccess -> RecordsResource
      RecordsAccess -> NotesResource
      RecordsAccess -> FormsResource
      /*RecordsAccess -> DocumentsResource*/
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager - RecordsResponse IEvaluationEngine.DiscloseRecords(RecordsDisclosureRequest) > EvaluationEngine
    ProcessManager -:q> CommunicationManager
    ProcessManager -> AuditAccess -> AuditResource
}

UseCase "User denies record change" {
  WebClient - IProcessManager.ReviewChanges() > ProcessManager
    /* Sub-usecase "SUB-Pr-1: Authorize User Access in Context" */
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
    ProcessManager -:q> CommunicationManager
    ProcessManager -> AuditAccess -> AuditResource
}

UseCase "Bulk import of records" {
  WebClient - SubmitRecordsResponse IProcessManager.SubmitRecords(SubmitRecordsRequest) > ProcessManager
    /* Sub-usecase "SUB-Pr-1: Authorize User Access in Context" */
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager - RecordOperationsResponse IRecordsAccess.Execute(RecordOperationsRequest) > RecordsAccess
      RecordsAccess -> RecordsResource
      RecordsAccess -> NotesResource
      RecordsAccess -> FormsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager - RecordsResponse IEvaluationEngine.DiscloseRecords(RecordsDisclosureRequest) > EvaluationEngine
    ProcessManager -:q> CommunicationManager
    ProcessManager -> AuditAccess -> AuditResource
}

UseCase "Bulk export of records" {
  WebClient -> ProcessManager
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager -> RecordsAccess
      RecordsAccess -> RecordsResource
      RecordsAccess -> NotesResource
      RecordsAccess -> FormsResource
    ProcessManager -> EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> AuditAccess -> AuditResource
}


Activity "Organization onboarding" {
  |u|User
  |s|System
  |support| Support
  |i|Identity Provider
  |support|
  start
  :Enter organization name and user email;
  |s|
  :Register invite parameters;
  :Sends invite link to contact;
  |u|
  :Access invite link;
  |s|
  :Requires user authentication and puts link into state;
  |i|
  :Create user identity;
  floating note left
    In the future we can require 
    a valid token from the system 
    in order to allow user sign up.
  end note
  |s|
  :Authenticate user;
  :Create user account for identity;
  :Retrieve invitation entry from forwarded state;
  :Validate invitation (e.g. expiration date);
  :Initialize configuration (organization, location, base policies...);
  :Create family and person;
  :Link user to person in location;
  |u|
  :Access CareTogether;
  stop
}


Activity "Invite user to existing organization" {
  |u1|User 1
  |u2|User 2
  |s|System
  |support| Support
  |i|Identity Provider
  |u1|
  start
  :Generates invite;
  |s|
  :Register invite parameters;
  :Sends invite link to contact;
  |u2|
  :Access invite link;
  :Enter personal data;
  |s|
  :Receive user data;
  :Retrieve invitation entry;
  :Validate invitation (e.g. expiration date);
  |i|
  :Create user identity;
  |s|
  :Create user account for identity;
  :Link user to organization;
  :Create family and person;
  :Authenticate user;
  |u2|
  :Access CareTogether;
  stop
}

UseCase "M0: Invite a User to Sign Up" {
  WebClient - IMembershipManager.InviteUser() > MembershipManager
    /* Sub-usecase "SUB-Pr-1: Authorize User Access in Context" */
    MembershipManager -> AccountsAccess -> AccountsResource
      AccountsAccess -> SecurityUtility
    MembershipManager -:q> CommunicationManager
}

UseCase "M1: Sign Up as a User" {
  @@@
  A person wants to sign up for a CareTogether account.
  This person MUST have an invite link to redeem, so their new account can
  be tied to an existing CareTogether organization or allow them to sign up
  a new organization.
  Signing up for an account without a connection to an organization makes no sense.
  @@@
  WebClient - IMembershipManager.SignUpUser() > MembershipManager
    MembershipManager - Account IAccountsAccess.GetOrCreateUserAccount(ClaimsPrincipal) > AccountsAccess
      AccountsAccess -> AccountsResource
      /* TODO: Separate out the "link user to existing organization" into a separate sub-usecase */
      AccountsAccess -> RecordsResource
    MembershipManager - ClaimsPrincipal ISecurityUtility.Authenticate(HttpContext) > SecurityUtility 
}

UseCase "M1: Sign Up as a User (copy)" {
  @@@
  A person wants to sign up for a CareTogether account.
  This person MUST have an invite link to redeem, so their new account can
  be tied to an existing CareTogether organization or allow them to sign up
  a new organization.
  Signing up for an account without a connection to an organization makes no sense.
  @@@
  WebClient - IMembershipManager.SignUpUser(InvitationId) > MembershipManager
    MembershipManager - INetworkAccess.RedeemOrganizationInvitationTableEntry() > NetworkAccess -> NetworkResource
    MembershipManager - Account IAccountsAccess.GetOrCreateUserAccount(ClaimsPrincipal) > AccountsAccess -> AccountsResource
  
    /* Optional: only initialize config. if it's an invite to sign up organization, 
       otherwise just link the user/person to existing organization. */
    MembershipManager - IConfigurationAccess.InitializeConfiguration() > ConfigurationAccess -> ConfigurationResource
    
    MembershipManager - IRecordsAccess.CreatePerson() > RecordsAccess -> RecordsResource
    MembershipManager - ClaimsPrincipal ISecurityUtility.Authenticate(HttpContext) > SecurityUtility 
}

UseCase "M1: Sign Up as a User (copy 2)" {
  @@@
  A person wants to sign up for a CareTogether account.
  This person MUST have an invite link to redeem, so their new account can
  be tied to an existing CareTogether organization or allow them to sign up
  a new organization.
  Signing up for an account without a connection to an organization makes no sense.
  @@@
  WebClient - IMembershipManager.SignUpUser(InvitationId) > MembershipManager

    /* This steps occurs in the backend or in the browser? */
    MembershipManager - ISecurityUtility.CreateUserIdentity() > SecurityUtility

    MembershipManager - ClaimsPrincipal ISecurityUtility.Authenticate(HttpContext) > SecurityUtility 
    MembershipManager - Account IAccountsAccess.CreateUserAccount(ClaimsPrincipal) > AccountsAccess -> AccountsResource
    MembershipManager - INetworkAccess.RedeemOrganizationInvitationTableEntry() > NetworkAccess -> NetworkResource

    /* Optional: only initialize config. if it's an invite to sign up organization, 
       otherwise just link the user/person to existing organization. */
    MembershipManager - IConfigurationAccess.InitializeConfiguration() > ConfigurationAccess -> ConfigurationResource

    /* Creates family and person, and links user to person in location */
    MembershipManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
}

UseCase "Invite a User to Sign Up an Organization" {
  @@@
  A CareTogether team representative wants to invite a leader in an
  organization to sign up their organization in CareTogether.
  The team representative will generate an invite link and send it
  to the leader, who may or may not already have a CareTogether account,
  i.e. the invite link will need to double as a user invite link and as an
  organization sign-up link.
  The sign-up link needs to be:
    - self-enforcing ("Person X can sign up organization Y"),
    - self-expiring ("Valid until X/Y/ZZ"),
    - trustworthy (digitally signed by CareTogether), and
    - (optionally) confidential (encrypted by CareTogether).
  It also needs to be short, i.e. the link itself should just be a UUID. To make
  links easy to find in a database, a UUIDv7 should be used.
  Links should expire within 24 hours.
  The invitation process involves a "sales" workflow to send reminders with updated links
  that encourage the user to complete the sign-up process.
  The invitation process can include defining the initial relationships that the organization
  may have with (especially local) network partners, which can further incentivize the sign-up process and
  enhance post-conversion "user activation".
  Links that allow both user sign-up and organization sign-up could be composite links, e.g.:
  https://app.caretogether.io/signup?user_invite={123}&org_invite={456}
  @@@
  /* Inviting a user can optionally include inviting them to create a specific organization. */
  SupportClient - OrganizationInvitation IMembershipManager.InviteOrganization(OrganizationInviteCriteria) > MembershipManager
    /* The invitation workflow can send reminders with renewed links. */
    MembershipManager -> WorkflowsAccess -> WorkflowsResource
    MembershipManager - INetworkAccess.CreateOrganizationInvitationTableEntry() > NetworkAccess -> NetworkResource
    MembershipManager -> AuditAccess -> AuditResource
    MembershipManager -:q> CommunicationManager
}

DTO OrganizationInviteCriteria {
    /* TODO: Include initial network partners, to help bootstrap the network & accelerate "activation" */
}

/* REVIEW BEGINS */
UseCase "M2: Sign Up an Organization" {
  @@@
  A leader in an organization wants to sign up for CareTogether.
  The leader must previously have signed up for a CareTogether account [M1], potentially with
  the same invite link and immediately prior to this step.
  The leader MUST have an invite link that grants them the ability to sign up their specific organization.
  @@@
  WebClient - IMembershipManager.SignUpOrganization(OrganizationInvitationId) > MembershipManager
    /* We cannot authorize this particular use case on the basis of organizational policies, because the
       organization itself does not exist at the beginning of the use case.
       The security checks are therefore very basic. */
    MembershipManager -> SecurityUtility
    /* Initiate an organization onboarding workflow.
       "Charity starts at home" -- when a new organization signs up, existing members can help them
       reach "activation" which is something the onboarding workflow needs to help facilitate. */
    MembershipManager -> WorkflowsAccess -> WorkflowsResource
    MembershipManager - INetworkAccess.RedeemOrganizationInvitationTableEntry() > NetworkAccess -> NetworkResource
    /* Set the initial configuration for an organization.
       To begin with, this will largely be blank, but in the future this could allow for tying into
       collaborative networks' shared "best practices", compliance rules, etc.
       This also includes creating the initial location for the organization and
       granting the leader the OrganizationAdministrator role across their entire organization. */
    /*TODO: Review the "bootstrapping" problem of how to grant the first user access to the first location, and
            how to grant people access to other locations than their default location.
            Could define a (better) process for the support team, at a minimum, but self-service is important too. */
    MembershipManager - IConfigurationAccess.InitializeConfiguration() > ConfigurationAccess -> ConfigurationResource
    MembershipManager -> AuditAccess -> AuditResource
    MembershipManager -:q> CommunicationManager
}


|