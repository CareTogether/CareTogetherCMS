UseCase Purpose {
@@@
# Purpose
The following fundamental statements define and guide both the CareTogether organization and platform.

## Mission

To make human services more relational.

## Objectives

1. Minimize the risk of platform-level as well as organization-level data breaches for all customers, while mitigating the impact of individual-level user account takeovers.
2. Ensure system resilience, including providing for long-term support and maintenance.
3. Help customers establish and maintain regulatory compliance.
4. Help customers optimize their processes and communications.
5. Allow even the smallest human services organizations to fully adopt the system.
6. Enable even the largest human services organizations to fully embrace the platform, including qualifying for relevant grants.
7. Build a network of partnering human services organizations that can provide wrap-around support to participants in a geographic area.
8. Empower partners and AI agents to fully leverage the platform.
9. Provide the highest quality user experience in the industry for all users.
10. Build the capacity to serve the ~300,000 human services organizations in the United States and supporting global use.
11. Enable longitudinal studies of human services outcomes and impact in order to identify and share best practices with organizations.
12. Provide an avenue for self-insurance.

## Vision

Develop a case management platform that reimagines connection for human services.

@@@
}

UseCase Glossary {
@@@
# Glossary
The following terms need to be understood and used consistently throughout both the CareTogether organization and platform.

## Voice
These terms capture the "brand voice" of CareTogether. They MUST be used only with the exact meanings that they are given here.

- **Relational** - an approach to human services that emphasizes transformation via relationships, as opposed to a *transactional* approach that often fails to achieve lasting change. See [The Rise of Antipoverty Relational Work
(Stanford Social Innovation Review, 2015)](https://ssir.org/articles/entry/the_rise_of_antipoverty_relational_work).

## Who?
- **Organizations** are human services organizations. Organizations can be formally or informally organized. Formal organizations include both nonprofit and for-profit private-sector organizations as well as government organizations.
- **Locations** are geographically focused areas in which a specific group of people within an organization serve participants (perhaps under more than one program). Locations do not have a strict definition, but they are best defined by travel time, i.e., they should be small enough that the people who serve the participants within that location can physically interact. For example, two cities (or counties, or parts of a larger metropolitan area) that are separated by more than an hour or two of travel time should typically be separate locations. A _case_ is always tied to a single location.
- **Programs** are the actual services, comprised of policies and procedures, that an organization offers to its participants. The mapping between locations and programs is N-to-M: multiple programs within the same location can serve the same participants, and an organization may not offer the same programs at all of its locations. Program policies and procedures can vary by location.
- Policies
- Procedures
- Staff
- Volunteers
- **participants** (sometimes referred to as partnering families) ...
- Referral Partner - another HSO that agrees to receive outbound referrals made by an HSO and/or provides inbound referrals to an HSO

## What?

Membership of organizations, staff, volunteers, and participants
Processes for following the organization's policies and procedures
Communication with staff, volunteers, participants, and referral partners

## How?


## Where?

Human Services - official definition? Do we narrow this?

Platform

System

Case

Case Management

Referral

Approval

Role

Arrangement

(Arrangement) Function

@@@
}


/*
## Use Cases (Activity Diagrams)
*/

Activity "XYZ" {}

/*
## Core Use Cases

### Membership

### Process

### Communication

*/

UseCase Volatilities {
@@@
## Volatilities

- XYZ
@@@
}


StaticAspect "CareTogether V2" { 
  WebClient MobileClient VoiceClient SupportClient AnalyticsClient IntegrationClient
  MembershipManager ProcessManager CommunicationManager AnalysisManager /* future enhancement */
  EvaluationEngine
MatchingEngine /* Possible volatility? */
  AccountsAccess NetworkAccess ConfigurationAccess WorkflowsAccess AuditAccess RecordsAccess
  /*NOTE: RecordsAccess -- Cosmos DB Graph API & Cosmos DB 'SQL' API, allowing Geode pattern */
  AccountsResource NetworkResource ConfigurationResource:f WorkflowsResource AuditResource RecordsResource 
 NotesResource:f DocumentsResource:f FormsResource:a
  EventLogUtility
  FileStoreUtility
  ObjectStoreUtility
  TelephonyUtility
  EmailUtility
  PushNotificationUtility
  PubSubUtility
  SecurityUtility
  LoggingUtility
}


/*
## Use Cases (Call Chains & Sequence Diagrams), Detailed Design
*/

/* OPERATION CONTRACTS -- WORK-IN-PROGRESS

ProcessManager
  - ConfigureOrganization
  - ConfigurePolicies // could end up just being part of ConfigureOrganization? maybe just call it 'Configure' & use polymorphism?
  - SubmitRecords // (un)archive is a special case that could just be a validation rule: 'IsActive' flag changes cannot be accompanied by other changes
    // SubmitRecords could actually update the record *or* decide to create a change request instead, based on policies
    // When a change request is issued, the ProcessManager makes a queued call to CommunicationManager to notify the record owner or other responsible party (as identified by policy evaluation) of the pending change.
  - RetrieveRecords
  - ReviewChanges

MembershipManager
  - InviteUser
  - RegisterAccount
  - CloseAccount
  - LinkAccount // links an account to a person in a location in an organization
  - FindAccount

CommunicationManager
  ...
  // The CommunicationManager has the ability to send email notifications as well as interactive notifications,
  // e.g. Teams adaptive cards, for things like change request approvals.

WorkflowsAccess
  - WorkflowState Instantiate(WorkflowCriteria) // 'run user-defined actions'?
  - WorkflowState Dispatch(InputEvent)

RecordsAccess
  - Create
  - Change
  - Filter
  - ProposeChange // add a new pending change to the underlying record's set of pending changes
  - CommitChange // needs to reference an existing pending change
  - CancelChange // needs to reference an existing pending change
    // Records include: Families, Communities, Organizations
    // Organizations could themselves be using CareTogether, allowing features like automatic transfer of intake data

// Records need to include a set of 'pending changes', each of which has a 'RequestedChangeId' that is tied to the request workflow.
// Pending changes should be stored in non-immutable storage, like draft notes are today, and only the reference to them should be
//   made part of the immutable log.

ConfigurationAccess
  ...

AccountsAccess
  ...

AuditAccess
  ...

*/

/*
QUESTION: What are we storing/exposing with RecordsAccess?

Option 1: only specific "Aggregates" as defined today: Families, Communities, Referrals, eventually Organizations.
>>> This feels the most consistently organized.

Option 2: all "Entities" in the domain model: Families, People, Referrals, Cases, Arrangements, Communities, Organizations.
This would actually also need to include:
- Requirement Completions/Exemptions
- Child Location Changes (Actual & Planned)
- Function Assignments
- Notes
- Documents (reference to them)
- Forms (reference to them)
- Organization Members
- Organization Roles

--> This approach basically exposes a relational database!

SMELL: This is fine-grained, not coarse-grained. We want to encapsulate the variability of different types of records.
SMELL: How do you define a 'pending change' to a requirement completion? What would be an example? On the other hand, it feels very reasonable to make a 'pending change' to a *family* (or maybe a person or arrangement or referral or case?) of a requirement completion, e.g. a family coach submitting a safety visit completion. Therefore, treating a Requirement Completion *as a record* is too granular. Therefore, we need some level of combining these "entities" into "aggregates" that are reasonable to modify.

Option 3?

Option 4: The entire dataset for a location? Waaaaay too coarse-grained. Writes need to be made at a more granular level.

*/

/*
# MIGRATION NOTES
- Authorize*CommandAsync methods move into the Resource Access layer (primarily into RecordsAccess)
*/

Activity "UC-Me-1: Sign In" {
  |u|User
  |s|System
  |u|
  start
  :Browse to CareTogether;
  if (User signed in) is (no) then
    :Redirect to Sign-In Screen;
    |s|
    :Determine sign-in methods to offer;
    |u|
    :Select sign-in method;
    :Enter credentials;
    |s|
    :Load user account;
  else (yes)
  end if
  |u|
  :Open Dashboard;
  stop
}

/* TODO: review */
UseCase "UC-Me-1: Sign In" {
  WebClient - ClaimsPrincipal ISecurityUtility.Authenticate(HttpContext) > SecurityUtility
  WebClient - AppUserAccount IMembershipManager.SignIn(ClaimsPrincipal) > MembershipManager
  MembershipManager - Account IAccountsAccess.GetOrCreateUserAccount(ClaimsPrincipal) > AccountsAccess
  AccountsAccess -> AccountsResource /*  Account IAccountsResource.GetOrCreateUserAccount(UserId) */
  AccountsAccess -> RecordsResource
}

/* HttpContext DTO is provided by ASP.NET Core */
/* ClaimsPrincipal DTO is provided by System.Security.Claims */

DTO AppUserAccount {
  Guid UserId
  /*TODO: Define this*/
}

DTO Account {
  Guid UserId
  AccountOrganizationAccess[] Organizations
}

DTO AccountOrganizationAccess {
  Guid OrganizationId
  AccountLocationAccess[] Locations
}

DTO AccountLocationAccess {
  Guid LocationId
  Guid PersonId
  string[] Roles
}

Activity "UC-Pr-1: Open Location" {
  |c|Client
  |s|System
  |c|
  start
  :Sign In
    ""<color:#777>[UC-Me-1]</color>"";
  :Select Organization;
  :Select Location;
  |s|
  :Authorize User Access in Context
    ""<color:#777>[SUB-Pr-1]</color>"";
  :Load Location Data; 
  'NOTE: This will also be the Process Manager
  |c|
  :View Location Dashboard;
  stop
}

UseCase "UC-Pr-1: Open Location" {
  WebClient -> ProcessManager
  ProcessManager -> EvaluationEngine
}

UseCase "SUB-Pr-1: Authorize User Access in Context" {
  ProcessManager - ContextPermissions IEvaluationEngine.AuthorizeUserAccess(AuthorizationContext) > EvaluationEngine
    EvaluationEngine -> AccountsAccess -> AccountsResource
    EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    EvaluationEngine -> RecordsAccess -> RecordsResource
  ProcessManager -> SecurityUtility
}

DTO AuthorizationContext { }

/*BUG: DTO inheritance is not supported*/
/*DTO GlobalAuthorizationContext : AuthorizationContext {}*/

UseCase "Retrieve Records" {
  WebClient - RetrieveRecordsResponse IProcessManager.RetrieveRecords(RetrieveRecordsRequest) > ProcessManager
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager - RecordsResponse IRecordsAccess.Filter(RecordsCriteria) > RecordsAccess
      RecordsAccess -> RecordsResource
      RecordsAccess -> NotesResource
      RecordsAccess -> FormsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager - RecordsResponse IEvaluationEngine.DiscloseRecords(RecordsDisclosureRequest) > EvaluationEngine
    /* Include disclosure & authorization results */
    ProcessManager -> AuditAccess -> AuditResource
}

DTO RetrieveRecordsRequest {
  DisclosureMethod Method
  RecordType? RecordType
  Guid? OrganizationId
  Guid? LocationId
  Filters? Filters
}

DTO Filters { }

DTO RetrieveRecordsResponse {
  Community[] Communities
  Family[] Families
  Organization[] Organizations
}

DTO Family {
  Guid Id,
  Guid LocationId,
  string Name,
  string? PrimaryEmail,
  string? PrimaryPhoneNumber,
  Address? PrimaryAddress,
  string? HomeChurch
}

DTO Address {
  string? Line1,
  string? Line2,
  string? City,
  string? Country,
  string? State,
  string? PostalCode
}

DTO Community {
    Guid Id,
    Guid LocationId,
    string Name
}

DTO Organization {}

DTO ContextualPermissions {
  AuthorizationContext Context
  string[] AllowedActions
  Account Account,
}

DTO RecordsDisclosureRequest {
  ContextualPermissions Permissions
  DisclosureMethod Method
  RecordsAccess.RecordsResponse Records
}

DTO RecordsCriteria {
  ContextualPermissions Permissions
  DisclosureMethod Method
  RecordType? RecordType
  Guid? OrganizationId
  Guid? LocationId
}

DTO RecordsResponse {
  Community[] Communities
  Family[] Families
  Organization[] Organizations
}

UseCase "UC-Pr-6: Submit Recods (create or change)" {
  WebClient - SubmitRecordsResponse IProcessManager.SubmitRecords(SubmitRecordsRequest) > ProcessManager
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager - RecordOperationsResponse IRecordsAccess.Execute(RecordOperationsRequest) > RecordsAccess
      RecordsAccess -> RecordsResource
      RecordsAccess -> NotesResource
      RecordsAccess -> FormsResource
      /*RecordsAccess -> DocumentsResource*/
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager - RecordsResponse IEvaluationEngine.DiscloseRecords(RecordsDisclosureRequest) > EvaluationEngine
    ProcessManager -:q> CommunicationManager
    ProcessManager -> AuditAccess -> AuditResource
}

DTO RecordOperation { } /* This can inclue create/change/propose change/commit change/cancel change */

DTO RecordOperationsRequest {
    ClaimsPrincipal 
    RecordOperation[] Operations
}

DTO SubmitRecordsRequest {
    Record[] Records
}


DTO Record {
  Guid Id
}

DTO RecordOperationsResponse {
    Record[] Records
}

DTO SubmitRecordsResponse {
    Record[] Records
}

/* TODO: check */
UseCase "UC-Pr-34: Discard Draft Notes" {
  WebClient - IProcessManager.ReviewChanges() > ProcessManager
  ProcessManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  ProcessManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
}

/* TODO: check */
UseCase "UC-Pr-35: Approve Notes" {
  WebClient - IProcessManager.ReviewChanges() > ProcessManager
  ProcessManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  ProcessManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
}

/* TODO: check */
UseCase "UC-Me-1: Invite Person User" {
  WebClient - IMembershipManager.InviteUser() > MembershipManager
  MembershipManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  MembershipManager -> AccountsAccess -> AccountsResource
}

/* TODO: account or records? */
UseCase "UC-Me-2: Edit Person User Protected Roles" {
  WebClient - IMembershipManager.ChangePersonRoles() > MembershipManager
  MembershipManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  MembershipManager - IAccountsAccess.Execute() > AccountsAccess -> AccountsResource
}

/* TODO: check */
UseCase "UC-Me-4: View Person User Login Info" {
  /* Feel like it should be similar to IProcessManager.RetrieveRecords()? */
  WebClient - IMembershipManager.FindAccount() > MembershipManager
  MembershipManager - IAccountsAccess.Filter() > AccountsAccess -> AccountsResource
  MembershipManager - IRecordsAccess.Filter() > RecordsAccess -> RecordsResource
  MembershipManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  MembershipManager - ISecurityUtility.GetUserLoginInfo() > SecurityUtility
}

UseCase "UC-Me-5: Edit Roles" {
  WebClient - IMembershipManager.ChangePersonRoles() > MembershipManager
  MembershipManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  MembershipManager - IAccountsAccess.Execute() > AccountsAccess -> AccountsResource
}

/* TODO: check */
UseCase "UC-Pr-76: Send Bulk SMS" {
  WebClient - ICommunicationManager.Notify() > CommunicationManager
  CommunicationManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  CommunicationManager - IRecordsAccess.Filter() > RecordsAccess -> RecordsResource
  CommunicationManager - ITelephonyUtility.Notify() > TelephonyUtility
}

DTO OpenCaseResponse {}

DTO OpenCaseRequest {}

/* ================== 1. Other use cases ================== */

/* ================== 1.1 RetrieveRecords Permutations ================== */

Activity "UC-Pr-2: View Communities List" {
  |c|Client
  |s|System
  |c|
  start
  :Open Location
    ""<color:#777>[UC-Pr-1]</color>"";
  :Select Communities Screen;
  |s|
  :List Communities for User;
  |c|
  :Display Communities List;
  stop
}

UseCase "View Communities List" {
@@@
### Prerequisites
- `ContextPermissions` for 'All Communities' context
@@@
  WebClient - IProcessManager.RetrieveRecords() > ProcessManager
    ProcessManager - IRecordsAccess.Filter() > RecordsAccess
      RecordsAccess -> SecurityUtility
      RecordsAccess -> RecordsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> EvaluationEngine
}

/* TODO: Missing FileStorageUtility? */
UseCase "UC-Pr-18: Read Family Documents" {
  WebClient - IProcessManager.RetrieveRecords() > ProcessManager
    ProcessManager - IRecordsAccess.Filter() > 
      RecordsAccess -> SecurityUtility
      RecordsAccess -> RecordsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> EvaluationEngine
}

/* TODO: check */
UseCase "UC-Pr-23: Access Settings Screen" {
  WebClient - IProcessManager.RetrieveRecords() > ProcessManager
    ProcessManager - IRecordsAccess.Filter() > 
      RecordsAccess -> SecurityUtility
      RecordsAccess -> RecordsResource
      RecordsAccess -> ConfigurationResource
      RecordsAccess -> AccountsResource
      RecordsAccess -> FormsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> EvaluationEngine
}

/* ================== 1.2 SubmitRecords Permutations ================== */

UseCase "Track Child Location" {
  WebClient - CreateChildLocationEntryResponse IProcessManager.SubmitRecords(TrackChildLocationChange) > ProcessManager
    ProcessManager - StoreChildLocationEntryResponse IRecordsAccess.Execute(ChildLocationEntry) > RecordsAccess 
      RecordsAccess -> SecurityUtility
      RecordsAccess -> RecordsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> EvaluationEngine
}

DTO CreateChildLocationEntryResponse { }

DTO TrackChildLocationChange {
    Guid FamilyId
    Guid ReferralId
    Guid[] ArrangementIds
    DateTime ChangedAtUtc
    Guid ChildLocationFamilyId
    Guid ChildLocationReceivingAdultId
    ChildLocationPlan Plan
    Guid? NoteId
}

DTO StoreChildLocationEntryResponse { }

DTO ChildLocationEntry {
    Guid ArrangementId,
    Guid ChildPersonId,
    Guid FamilyId,
    DateTime StartedAtUtc,
    ChildLocationPlan ChildcarePlan,
    DateTime? EnededAtUtc,
    TimeSpan Duration
}

UseCase "UC-Pr-19: Upload Family Documents" {
  WebClient - IProcessManager.SubmitRecords() > ProcessManager
    ProcessManager - IRecordsAccess.Execute() > 
      RecordsAccess -> SecurityUtility
      RecordsAccess -> RecordsResource /* TODO: Do we store a reference for the file? Should it be done after calling FileStoreUtility? */
      RecordsAccess - IFileStoreUtility.Upload() > FileStoreUtility
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> EvaluationEngine
}

UseCase "UC-Pr-20: Archive Family Documents" {
  WebClient - IProcessManager.SubmitRecords() > ProcessManager
    ProcessManager - IRecordsAccess.Execute() > 
      RecordsAccess -> SecurityUtility
      RecordsAccess -> RecordsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> EvaluationEngine
}

/* TODO: check */
UseCase "UC-Pr-64: Upload Community Documents" {
  WebClient - IProcessManager.SubmitRecords() > ProcessManager
  ProcessManager - ContextualPermissions IEvaluationEngine.CalculateContextualPermissions(LocationAuthorizationContext) > EvaluationEngine
  ProcessManager - IFileStoreUtility.Upload() > FileStoreUtility
  ProcessManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
}

UseCase "UC-Pr-81: Open Case" {
  WebClient - OpenCaseResponse IProcessManager.SubmitRecords(OpenCaseRequest) > ProcessManager
  ProcessManager - IEvaluationEngine.AuthorizeUserAccess() > EvaluationEngine
  EvaluationEngine -> AccountsAccess -> AccountsResource
  EvaluationEngine -> RecordsAccess -> RecordsResource
  EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
  ProcessManager - IWorkflowsAccess.Instantiate() > WorkflowsAccess -> WorkflowsResource
  ProcessManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
  ProcessManager - ICommunicationManager.Notify():q> CommunicationManager
}

UseCase "Open Referral" {
  WebClient - OpenCaseResponse IProcessManager.SubmitRecords() > ProcessManager
  ProcessManager - IEvaluationEngine.AuthorizeUserAccess() > EvaluationEngine
  EvaluationEngine -> AccountsAccess -> AccountsResource
  EvaluationEngine -> RecordsAccess -> RecordsResource
  EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
  ProcessManager - IWorkflowsAccess.Instantiate() > WorkflowsAccess -> WorkflowsResource
  ProcessManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
  ProcessManager - ICommunicationManager.Notify():q> CommunicationManager
}

/* ================== 2. Other Data Models ================== */

DTO CreateReferral /* : RecordOperation */ {
    string Comments
    Guid? FamilyId
}

DTO Referral /* : Record */ {
    string Comments
    Guid? FamilyId
}

DTO CreateArrangementResponse { }

DTO CreateArrangementRequest { }

DTO StoreArrangementEntryResponse { }

DTO ArrangementEntry {
    Guid Id,
    string ArrangementType,
    bool Active,
    DateTime RequestedAtUtc,
    DateTime? StartedAtUtc,
    DateTime? EndedAtUtc,
    DateTime? CancelledAtUtc,
    DateTime? PlannedStartUtc,
    DateTime? PlannedEndUtc,
    Guid PartneringFamilyPersonId,
    ImmutableList<CompletedRequirementInfo> CompletedRequirements,
    ImmutableList<ExemptedRequirementInfo> ExemptedRequirements,
    ImmutableList<IndividualVolunteerAssignment> IndividualVolunteerAssignments,
    ImmutableList<FamilyVolunteerAssignment> FamilyVolunteerAssignments,
    ImmutableSortedSet<ChildLocationHistoryEntry> ChildLocationHistory,
    ImmutableSortedSet<ChildLocationHistoryEntry> ChildLocationPlan,
    string? Comments,
    string? Reason
}

DTO CompletedRequirementInfo {
    Guid UserId,
    DateTime TimestampUtc,
    Guid CompletedRequirementId,
    string RequirementName,
    DateTime CompletedAtUtc,
    DateTime? ExpiresAtUtc,
    Guid? UploadedDocumentId,
    Guid? NoteId
}

DTO ExemptedRequirementInfo {
    Guid UserId,
    DateTime TimestampUtc,
    string RequirementName,
    DateTime? DueDate,
    string AdditionalComments,
    DateTime? ExemptionExpiresAtUtc
}

DTO IndividualVolunteerAssignment {
    Guid FamilyId,
    Guid PersonId,
    string ArrangementFunction,
    string? ArrangementFunctionVariant,
    ImmutableList<CompletedRequirementInfo> CompletedRequirements,
    ImmutableList<ExemptedRequirementInfo> ExemptedRequirements
}

DTO FamilyVolunteerAssignment {
    Guid FamilyId,
    string ArrangementFunction,
    string? ArrangementFunctionVariant,
    ImmutableList<CompletedRequirementInfo> CompletedRequirements,
    ImmutableList<ExemptedRequirementInfo> ExemptedRequirements
}

DTO ChildLocationHistoryEntry {
    Guid UserId,
    DateTime TimestampUtc,
    Guid ChildLocationFamilyId,
    Guid ChildLocationReceivingAdultId,
    ChildLocationPlan Plan,
    Guid? NoteId
}

DTO CreateFamilyResponse { }

DTO CreateFamilyRequest { }

DTO StoreFamilyResponse { }

DTO RecordParameters { }

DTO FamilyRecordParameters /* : RecordParameters */ {
    Guid FamilyId
}

DTO AddFamilyMemberRequest {
  Person Person,
  Guid FamilyId
  FamilyAdultRelationshipInfo RelationToFamily
}

DTO Person {
  Guid PersonId,
  string FirstName,
  string LastName,
  Gender? Gender,
  Age? Age,
  string? Ethnicity,
  ImmutableList<Address> Addresses,
  Guid? CurrentAddressId,
  ImmutableList<PhoneNumber> PhoneNumbers,
  Guid? PreferredPhoneNumberId,
  ImmutableList<EmailAddress> EmailAddresses,
  Guid? PreferredEmailAddressId,
  string? Concerns,
  string? Notes
}

DTO AddPersonToFamily {
  Guid PersonId,
  Guid FamilyId,
  FamilyAdultRelationshipInfo RelationToFamily
}

DTO AddChildToFamily {
  Guid PersonId,
  Guid FamilyId,
  FamilyAdultRelationshipInfo RelationToFamily
}

DTO ArchivePersonRequest {
    Guid PersonId
}

DTO ArchivePersonCriteria {
    Guid PersonId
}

DTO ChangePersonFamilyRequest {
    Guid PersonId,
    Guid OriginalFamilyId,
    Guid TargetFamilyId,
}

/* ====================================================== */

/* 
Example draft implementation of changing a referral record.

Example SubmitRecordsRequest (ProcessManager.SubmitRecords input):

[{
  "Change": {
      "Comments": "Test",
      "Discriminator": "UpdateReferralComments",
      "FamilyId": "11111111-1111-1111-1111-111111111111",
      "ReferralId": "22222222-2222-2222-2222-222222222222",
  },
}]

var recordOperationsRequest = [
  {
    "Change": {
        "Comments": "Test",
        "Discriminator": "UpdateReferralComments",
        "FamilyId": "11111111-1111-1111-1111-111111111111",
        "ReferralId": "22222222-2222-2222-2222-222222222222",
    },
  }
]

recordsAccess.Execute(recordOperationsRequest);

// Check user's permissions.

// Apply change.

// Store patched record and append change to log.

*/

UseCase "System requests approval for record change" {
  WebClient - SubmitRecordsResponse IProcessManager.SubmitRecords(SubmitRecordsRequest) > ProcessManager
    /* Sub-usecase "SUB-Pr-1: Authorize User Access in Context" */
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager - RecordOperationsResponse IRecordsAccess.Execute(RecordOperationsRequest) > RecordsAccess
      RecordsAccess -> RecordsResource
      RecordsAccess -> NotesResource
      RecordsAccess -> FormsResource
      /*RecordsAccess -> DocumentsResource*/
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager - RecordsResponse IEvaluationEngine.DiscloseRecords(RecordsDisclosureRequest) > EvaluationEngine
    ProcessManager -:q> CommunicationManager
    ProcessManager -> AuditAccess -> AuditResource
}

UseCase "User approves record change" {
  WebClient - SubmitRecordsResponse IProcessManager.SubmitRecords(SubmitRecordsRequest) > ProcessManager
    /* Sub-usecase "SUB-Pr-1: Authorize User Access in Context" */
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager - RecordOperationsResponse IRecordsAccess.Execute(RecordOperationsRequest) > RecordsAccess
      RecordsAccess -> RecordsResource
      RecordsAccess -> NotesResource
      RecordsAccess -> FormsResource
      /*RecordsAccess -> DocumentsResource*/
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager - RecordsResponse IEvaluationEngine.DiscloseRecords(RecordsDisclosureRequest) > EvaluationEngine
    ProcessManager -:q> CommunicationManager
    ProcessManager -> AuditAccess -> AuditResource
}

UseCase "User denies record change" {
  WebClient - IProcessManager.ReviewChanges() > ProcessManager
    /* Sub-usecase "SUB-Pr-1: Authorize User Access in Context" */
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
    ProcessManager -:q> CommunicationManager
    ProcessManager -> AuditAccess -> AuditResource
}

UseCase "Bulk import of records" {
  WebClient - SubmitRecordsResponse IProcessManager.SubmitRecords(SubmitRecordsRequest) > ProcessManager
    /* Sub-usecase "SUB-Pr-1: Authorize User Access in Context" */
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager - RecordOperationsResponse IRecordsAccess.Execute(RecordOperationsRequest) > RecordsAccess
      RecordsAccess -> RecordsResource
      RecordsAccess -> NotesResource
      RecordsAccess -> FormsResource
    ProcessManager -> EvaluationEngine
      EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager - RecordsResponse IEvaluationEngine.DiscloseRecords(RecordsDisclosureRequest) > EvaluationEngine
    ProcessManager -:q> CommunicationManager
    ProcessManager -> AuditAccess -> AuditResource
}

UseCase "Bulk export of records" {
  WebClient -> ProcessManager
    ProcessManager -> WorkflowsAccess -> WorkflowsResource
    ProcessManager -> RecordsAccess
      RecordsAccess -> RecordsResource
      RecordsAccess -> NotesResource
      RecordsAccess -> FormsResource
    ProcessManager -> EvaluationEngine -> ConfigurationAccess -> ConfigurationResource
    ProcessManager -> AuditAccess -> AuditResource
}


Activity "Organization onboarding" {
  |u|User
  |s|System
  |support| Support
  |i|Identity Provider
  |support|
  start
  :Enter organization name and user email;
  |s|
  :Register invite parameters;
  :Sends invite link to contact;
  |u|
  :Access invite link;
  |s|
  :Requires user authentication and puts link into state;
  |i|
  :Create user identity;
  floating note left
    In the future we can require 
    a valid token from the system 
    in order to allow user sign up.
  end note
  |s|
  :Authenticate user;
  :Create user account for identity;
  :Retrieve invitation entry from forwarded state;
  :Validate invitation (e.g. expiration date);
  :Initialize configuration (organization, location, base policies...);
  :Create family and person;
  :Link user to person in location;
  |u|
  :Access CareTogether;
  stop
}


Activity "Invite user to existing organization" {
  |u|User
  |s|System
  |support| Support
  |i|Identity Provider
  |u|
  start
  :Generates invite;
  |s|
  :Register invite parameters;
  :Sends invite link to contact;
  |u|
  :Access invite link;
  :Enter personal data;
  |s|
  :Receive user data;
  :Retrieve invitation entry;
  :Validate invitation (e.g. expiration date);
  |i|
  :Create user identity;
  |s|
  :Create user account for identity;
  :Link user to organization;
  :Create family and person;
  :Authenticate user;
  |u|
  :Access CareTogether;
  stop
}

UseCase "M0: Invite a User to Sign Up" {
  WebClient - IMembershipManager.InviteUser() > MembershipManager
    /* Sub-usecase "SUB-Pr-1: Authorize User Access in Context" */
    MembershipManager -> AccountsAccess -> AccountsResource
      AccountsAccess -> SecurityUtility
    MembershipManager -:q> CommunicationManager
}

UseCase "M1: Sign Up as a User" {
  @@@
  A person wants to sign up for a CareTogether account.
  This person MUST have an invite link to redeem, so their new account can
  be tied to an existing CareTogether organization or allow them to sign up
  a new organization.
  Signing up for an account without a connection to an organization makes no sense.
  @@@
  WebClient - IMembershipManager.SignUpUser() > MembershipManager
    MembershipManager - Account IAccountsAccess.GetOrCreateUserAccount(ClaimsPrincipal) > AccountsAccess
      AccountsAccess -> AccountsResource
      /* TODO: Separate out the "link user to existing organization" into a separate sub-usecase */
      AccountsAccess -> RecordsResource
    MembershipManager - ClaimsPrincipal ISecurityUtility.Authenticate(HttpContext) > SecurityUtility 
}

UseCase "M1: Sign Up as a User (copy)" {
  @@@
  A person wants to sign up for a CareTogether account.
  This person MUST have an invite link to redeem, so their new account can
  be tied to an existing CareTogether organization or allow them to sign up
  a new organization.
  Signing up for an account without a connection to an organization makes no sense.
  @@@
  WebClient - IMembershipManager.SignUpUser(/*Guid*/ InvitationId) > MembershipManager
    MembershipManager - INetworkAccess.RedeemOrganizationInvitationTableEntry() > NetworkAccess -> NetworkResource
    MembershipManager - Account IAccountsAccess.GetOrCreateUserAccount(ClaimsPrincipal) > AccountsAccess -> AccountsResource
  
    /* Optional: only initialize config. if it's an invite to sign up organization, 
       otherwise just link the user/person to existing organization. */
    MembershipManager - IConfigurationAccess.InitializeConfiguration() > ConfigurationAccess -> ConfigurationResource
    
    MembershipManager - IRecordsAccess.CreatePerson() > RecordsAccess -> RecordsResource
    MembershipManager - ClaimsPrincipal ISecurityUtility.Authenticate(HttpContext) > SecurityUtility 
}

UseCase "M1: Sign Up as a User (copy 2)" {
  @@@
  A person wants to sign up for a CareTogether account.
  This person MUST have an invite link to redeem, so their new account can
  be tied to an existing CareTogether organization or allow them to sign up
  a new organization.
  Signing up for an account without a connection to an organization makes no sense.
  @@@
  WebClient - IMembershipManager.SignUpUser(/*Guid*/ InvitationId) > MembershipManager

    /* This steps occurs in the backend or in the browser? */
    MembershipManager - ISecurityUtility.CreateUserIdentity() > SecurityUtility

    MembershipManager - ClaimsPrincipal ISecurityUtility.Authenticate(HttpContext) > SecurityUtility 
    MembershipManager - Account IAccountsAccess.CreateUserAccount(ClaimsPrincipal) > AccountsAccess -> AccountsResource
    MembershipManager - INetworkAccess.RedeemOrganizationInvitationTableEntry() > NetworkAccess -> NetworkResource

    /* Optional: only initialize config. if it's an invite to sign up organization, 
       otherwise just link the user/person to existing organization. */
    MembershipManager - IConfigurationAccess.InitializeConfiguration() > ConfigurationAccess -> ConfigurationResource

    /* Creates family and person, and links user to person in location */
    MembershipManager - IRecordsAccess.Execute() > RecordsAccess -> RecordsResource
}

UseCase "Invite a User to Sign Up an Organization" {
  @@@
  A CareTogether team representative wants to invite a leader in an
  organization to sign up their organization in CareTogether.
  The team representative will generate an invite link and send it
  to the leader, who may or may not already have a CareTogether account,
  i.e. the invite link will need to double as a user invite link and as an
  organization sign-up link.
  The sign-up link needs to be:
    - self-enforcing ("Person X can sign up organization Y"),
    - self-expiring ("Valid until X/Y/ZZ"),
    - trustworthy (digitally signed by CareTogether), and
    - (optionally) confidential (encrypted by CareTogether).
  It also needs to be short, i.e. the link itself should just be a UUID. To make
  links easy to find in a database, a UUIDv7 should be used.
  Links should expire within 24 hours.
  The invitation process involves a "sales" workflow to send reminders with updated links
  that encourage the user to complete the sign-up process.
  The invitation process can include defining the initial relationships that the organization
  may have with (especially local) network partners, which can further incentivize the sign-up process and
  enhance post-conversion "user activation".
  Links that allow both user sign-up and organization sign-up could be composite links, e.g.:
  https://app.caretogether.io/signup?user_invite={123}&org_invite={456}
  @@@
  /* Inviting a user can optionally include inviting them to create a specific organization. */
  SupportClient - OrganizationInvitation IMembershipManager.InviteOrganization(OrganizationInviteCriteria) > MembershipManager
    /* The invitation workflow can send reminders with renewed links. */
    MembershipManager -> WorkflowsAccess -> WorkflowsResource
    MembershipManager - INetworkAccess.CreateOrganizationInvitationTableEntry() > NetworkAccess -> NetworkResource
    MembershipManager -> AuditAccess -> AuditResource
    MembershipManager -:q> CommunicationManager
}

DTO OrganizationInviteCriteria {
    /* TODO: Include initial network partners, to help bootstrap the network & accelerate "activation" */
}

/* REVIEW BEGINS */
UseCase "M2: Sign Up an Organization" {
  @@@
  A leader in an organization wants to sign up for CareTogether.
  The leader must previously have signed up for a CareTogether account [M1], potentially with
  the same invite link and immediately prior to this step.
  The leader MUST have an invite link that grants them the ability to sign up their specific organization.
  @@@
  WebClient - IMembershipManager.SignUpOrganization(/*Guid*/ OrganizationInvitationId) > MembershipManager
    /* We cannot authorize this particular use case on the basis of organizational policies, because the
       organization itself does not exist at the beginning of the use case.
       The security checks are therefore very basic. */
    MembershipManager -> SecurityUtility
    /* Initiate an organization onboarding workflow.
       "Charity starts at home" -- when a new organization signs up, existing members can help them
       reach "activation" which is something the onboarding workflow needs to help facilitate. */
    MembershipManager -> WorkflowsAccess -> WorkflowsResource
    MembershipManager - INetworkAccess.RedeemOrganizationInvitationTableEntry() > NetworkAccess -> NetworkResource
    /* Set the initial configuration for an organization.
       To begin with, this will largely be blank, but in the future this could allow for tying into
       collaborative networks' shared "best practices", compliance rules, etc.
       This also includes creating the initial location for the organization and
       granting the leader the OrganizationAdministrator role across their entire organization. */
    /*TODO: Review the "bootstrapping" problem of how to grant the first user access to the first location, and
            how to grant people access to other locations than their default location.
            Could define a (better) process for the support team, at a minimum, but self-service is important too. */
    MembershipManager - IConfigurationAccess.InitializeConfiguration() > ConfigurationAccess -> ConfigurationResource
    MembershipManager -> AuditAccess -> AuditResource
    MembershipManager -:q> CommunicationManager
}
