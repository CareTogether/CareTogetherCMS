| "Glossary"
UseCase Glossary {
@@@
# Glossary
The following terms need to be understood and used consistently throughout both the CareTogether organization and platform.

## Voice
These terms capture the "brand voice" of CareTogether. They MUST be used only with the exact meanings that they are given here.

- **Relational** - an approach to human services that emphasizes transformation via relationships, as opposed to a merely *transactional* approach that often fails to achieve lasting change. See [The Rise of Antipoverty Relational Work
(Stanford Social Innovation Review, 2015)](https://ssir.org/articles/entry/the_rise_of_antipoverty_relational_work).

## Who?
- **Organizations** are human services organizations. Organizations can be formally or informally organized. Formal organizations include both nonprofit and for-profit private-sector organizations as well as government organizations.
- **Locations** are geographically focused areas in which a specific group of people within an organization serve clients (perhaps under more than one program). Locations do not have a strict definition, but they are best defined by travel time, i.e., they should be small enough that the people who serve the clients within that location can physically interact. For example, two cities (or counties, or parts of a larger metropolitan area) that are separated by more than an hour or two of travel time should typically be separate locations. A _case_ is always tied to a single location.
- **Programs** are the actual services, comprised of policies and procedures, that an organization offers to its clients. The mapping between locations and programs is N-to-M: multiple programs within the same location can serve the same clients, and an organization may not offer the same programs at all of its locations. Program policies and procedures can vary by location.
- **Networks** are assocations of organizations, with various types of relationships established between them. For example, one organization may be a referral partner for another; referrals may flow in one direction or both between them. Other organizations (e.g., churches) may themselves represent communities of people who are helping within a program of another organization. There are also networks of networks, at several layers: a local ministry might have a network of partner churches for which they maintain records & processes in a program context, then that local ministry might participate in an area-wide referral partnership and support network, and then that area network might be part of a regional/national/international network sharing best practices and larger-scale resources (e.g., to offer capabilities like self-insurance for network members). A network can have subsets (which may not be isolated from each other but may share a common focus), e.g. an interest network or affinity network within ForCLT.
- Policies
- Procedures
- **Person** - any human being, about which we can store certain facts (name, contact info, etc.)
- **Family** -- sort of a fiction/loose concept (important to treat it as a dimension, perhaps, at a minimum) -- we already identify families by their primary contact
  - Record-keeping scope *may* vary by organization?
  - Reality of families is that they are a very nebulous concept, especially for many client families
- **Household** -- has some implications for approval rules, e.g. background checks for all household members is a policy
  - When people *leave a household* that's typically the trigger for the actual business activity of moving them to another family "entity" today in V1.
- "Contact" - someone from another organization who is tracked in the system, e.g. as a referral source
- Staff
  - Organizational function? Make this configurable? -- would be helpful to be explicit, and manually adjustable, re: which function(s) a person/family is
  - "organizational functions" apply to people (persons), but not necessarily to families: a family can be a volunteer family, can be a client family, but cannot be a staff family.
  - Families vs. households: need to revisit how we do recordkeeping around these overlapping concepts
- **Helpers** - people who are serving other people are called 'helpers' to be sufficiently general. Helpers may be volunteers or (paid or unpaid) staff. Note that unpaid staff have a more formal association with an organization than 'volunteers'. "Helpers" represent the counterpart to "Clients".
- **Clients** - Unfortunately in the IDesign Method, and software architecture generally, the term 'Client' is used for a specific technical purpose that is unrelated to this idea of a **program participant**, someone who is receiving the services offered by an HSO. However, the term **client** is the predominant (universally accepted) term in the human services sector. Thus, when talking about the _domain_, we refer to **clients**.
- Referral Partner - another HSO that agrees to receive outbound referrals made by an HSO and/or provides inbound referrals to an HSO

## What?

- **Membership** of organizations, staff, volunteers, and participants
- **Processes** for following the organization's policies and procedures
- **Communication** with staff, volunteers, participants, and referral partners

## How?


## Where?

Human Services - official definition? Do we narrow this?

Platform

System

Case -- NOTE: The term 'Need' may be more appropriate, especially at other levels of the fractal.

Case Management

Referral

Approval

Role

Arrangement

(Referral, Case, Arrangement) Function

(Function) Assignment

Community

Community Members

@@@
}

|
| "Purpose"
UseCase Purpose {
@@@
# Purpose
The following fundamental statements define and guide both the CareTogether organization and platform.

## Mission

To make human services more relational.

## Objectives

1. Minimize the risk of platform-level as well as organization-level data breaches for all customers, while mitigating the impact of individual-level user account takeovers.
2. Ensure system resilience, including providing for long-term support and maintenance.
3. Help customers establish and maintain regulatory compliance.
4. Help customers optimize their processes and communications.
5. Allow even the smallest human services organizations to fully adopt the system.
6. Enable even the largest human services organizations to fully embrace the platform, including qualifying for relevant grants.
7. Build a network of partnering human services organizations that can provide wrap-around support to participants in a geographic area.
8. Empower partners and AI agents to fully leverage the platform.
9. Provide the highest quality user experience in the industry for all users.
10. Build the capacity to serve the ~300,000 human services organizations in the United States and support global use.
11. Enable longitudinal studies of human services outcomes and impact in order to identify and share best practices with organizations.
12. Provide an avenue for self-insurance.
13. Assist organizations in networking based on insights into relevant potential partners.
14. Empower clients to maintain effective control of their personal data.

## Vision

Develop a case management platform that reimagines connection for human services.

@@@
}

|
| "Operational Concepts & Observations"

|
| "Use Case Family: Process"
/* The 'helping' use case family encompasses the actual services being provided to
   clients, which requires defining and evaluating policies,
   as well as procedures (workflows) for recordkeeping and oversight. */


Activity "Invite Person" {}
Activity "Accept Person Invitation" {}
Activity "Link New Login to Person" {}
Activity "Review Person Logins" {}



/* Facet: Organization Records */
Activity "Configure Organization" {} /* Core use case: includes authn, locations, programs, roles */
Activity "Configure Process" {} /* Core use case: includes policies, procedures, forms */



/* There is a symmetry between the need vetting (intake) process and the sign-up
   vetting (approval) process. */

Activity "Request to Serve" {
  |Client|
  start
  :Submit request;
  |System|
  :Validate request;
  if (Request valid?) then (no)
    |Client|
    :Error;
    stop
  else (yes)
    |System|
    :Publish request;
    stop
  endif
}

UseCase "Apply to Serve" {
  WebAppClient - IProcessManager.SubmitRequest() > ProcessManager
  ProcessManager - IEvaluationEngine.ValidateRequest() > EvaluationEngine
  EvaluationEngine - IConfigurationAccess.LoadPolicy() > ConfigurationAccess -> ConfigurationResource
  ProcessManager - IPubSubUtility.Publish() > PubSubUtility
}

Activity "Apply for Membership - Person to Organization" {
  |Client|
  start
  :Submit request;
  |System|
  :Validate request;
  if (Request valid?) then (no)
    |Client|
    :Error;
    stop
  else (yes)
    |System|
    :Publish request;
    stop
  endif
} /*TODO:
    This is a tricky problem to resolve for our fractal, if it is one?
    The problem of a 'household of one' arises when a person then has to be in
    two or more different 'households', e.g. once as a family coach and once as
    a parent in a host family. The person is trying to participate both as a
    family coach and as a host parent. The host parent participation is easy to
    model as a household, because everyone in the household is participating in
    serving as a host family (with possible exceptions, e.g. adult children
    living at home). The family coach approval rules are all individual; the
    host family approval rules are a combination of individual and family level.
*/

/*TODO: Eventually need to discuss invitations, discovery, etc. */

/* The system deals with policies and procedures in the Process Manager.
   Policies are system-enforced invariants (although users can exempt policy requirements with the right permissions),
   and so policy *evaluation* is handled by the EvaluationEngine. This logic exists in V1 today. A future rewrite may implement a DSL here.
   For now, the 'EvaluateApproval' activity for the approval policy is just an activity in the Elsa workflow.

   Our first pass is that every Elsa activity should be an operation on a SoEx service. Later on we can introduce composite activities.

   Procedures are freeform drag-and-drop workflows that hook into the invariant elements of the system,
   from a ready-made closed set of activities, e.g.,
   an 'Approval Procedure' will need to be defined per "tenant" (possibly more granular, e.g. varying by program). */

/* This use case is for configuring a policy (whether a true DSL or not) */
UseCase "Configure Membership Approval Policy" {
  WebAppClient - ConfigurePolicy(ApprovalPolicy) > ProcessManager
  /*TODO: Validate the policy */
  ProcessManager - Store(ApprovalPolicy) > ConfigurationAccess -> ConfigurationResource
}

/* For now, this could be done out-of-band using Elsa Studio behind the scenes.
   In the future, this needs to be integrated into the WebAppClient and the ProcessManager needs to orchestrate the use case. */
UseCase "Configure Membership Approval Procedure" {
  SupportClient - Edit(WorkflowDefinition) > WorkflowUtility
}

UseCase "Apply for Membership - Person to Organization" {
  /* MembershipApplication is applicable to both volunteer applications (organization level), membership applications (area network), membership applications (regional network)... */
  WebAppClient - WorkflowInstance IProcessManager.SubmitRequest(MembershipApplication) > ProcessManager
  /* The workflow stores the sequence/flowchart of actions to take in the helper approval process. */
  /*BLAIR: IMembershipSomething etc. breaks the parser */
  /* The approval process starts with a membership application. It ends with an approval decision. */
  ProcessManager - WorkflowInstance IWorkflowUtility.Approve(MembershipApplication) > WorkflowUtility

  /*TODO: How do we represent to the user "what is left to do" -- i.e., the full past & future of the workflow?
          What actions are past-due, which ones were exempted, etc.
          And subject to access levels (who can see certain actions)...
          Part of the steps in the workflow update the UI -- send XAML etc. -- or fire events,
          have clients monitor the events. ---> all async via queues */
}

DTO WorkflowInstanceId {} /* GUID value type */

DTO WorkflowInstance {
  WorkflowInstanceId Id
  WorkflowState State
}

UseCase "Validate Membership Application" {
  ProcessManager - IEvaluationEngine.Validate(MembershipApplication) > EvaluationEngine
  EvaluationEngine - Policy IConfigurationAccess.LoadPolicy() > ConfigurationAccess -> ConfigurationResource
}

UseCase "Validate Referral Request" {
  ProcessManager - IEvaluationEngine.Validate(ReferralRequest) > EvaluationEngine
  EvaluationEngine - Policy IConfigurationAccess.LoadPolicy() > ConfigurationAccess -> ConfigurationResource
}

UseCase "Evaluate Approval Policy" {
  /* The workflow can decide, based on the ApprovalResult ('outcome' in Elsa terms), what to do next. */
  ProcessManager - ApprovalResult IEvaluationEngine.Review(MembershipApplication) > EvaluationEngine
  EvaluationEngine - Policy IConfigurationAccess.LoadPolicy() > ConfigurationAccess -> ConfigurationResource
  /* Fancy internal algorithm runs here */
  EvaluationEngine - IRecordsAccess.Store(ApprovalResult) > RecordsAccess -> RecordsResource
}

UseCase "Publish Membership Application Approval Request" {
  ProcessManager - IMembershipEvent.OnApplicationReceived(MembershipApplication) > PubSubUtility
  /* The PubSubUtility will pass this to its subscribers. Subscribers *also* implement IMembershipEvents */
}

/* PWCF: Transient subscribers vs. persistent subscribers... */
/* Subscription management application... -- in domain-informed terms */

UseCase "Configure Membership Application Approval Request Subscription" {
  /*BLAIR: 'IMembershipEventPublisher' is not allowed? */
  SupportClient - IPublishMembershipEvent.AddMembershipApplicationApprover(ApproverParameters) > PubSubUtility
}

UseCase "Receive Membership Application Approval Request" {
  /* The implementation of this will send the email that based on the channel */
  PubSubUtility - IMembershipEvent.OnApplicationReceived(MembershipApplication) > MessagingUtility
}

/*TODO: How do we notify potential approvers that there is something to approve?
        We need to post an event... */

/*TODO: This is an example, needs to be refined further */
UseCase "Approve Membership Application Document" {
  WebAppClient -> ProcessManager
  ProcessManager - WorkflowState IWorkflowsAccess.ResumeWorkflow(ResumeParameters) > WorkflowUtility
}

DTO ResumeParameters {
  WorkflowInstanceId Id /* The specific workflow instance to resume */
  ActivityId ActivityId /* The activity that was completed by the user/system client. */
  /*TODO: Need to source-generate the known types for this */
  T Parameters /* The DTO representing the values to provide */
}


UseCase "Check Application Status" {
  @@@
  Could be via polling or the first time you sign into the web app in a new browser, or both.
  @@@
  WebAppClient - MyWorkflows CheckStatus() > ProcessManager
  ProcessManager - MyWorkflows CheckStatus() > EvaluationEngine
  /* UserCriteria can include interval, status, etc. */
  EvaluationEngine - InterrogateWorkflows(UserCriteria) > WorkflowUtility
  /* TODO: Apply access level disclosure logic */
  /* NOTE: In the future, we could apply prioritization logic based on severity, dependencies, compliance, etc. */
}


UseCase "Alter Policies & Procedures" {
  /* We need to compile domain-specific procedures into workflow definitions. Here, we do this on the fly.
     We could alternatively do this only whenever the policy/procedure is altered. */
  ProcessManager - IEvaluationEngine.CompileProcedure() > EvaluationEngine
  EvaluationEngine - IConfigurationAccess.LoadProcedure() > ConfigurationAccess -> ConfigurationResource
}


Activity "Begin (membership) vetting ('helper approval') process" {
  |System|
  start
  :Receive request;
  :Create helper approval;
  :Determine vetting actions;
  note: Start workflow?;
  :Store helper approval actions;
  :Publish helper approval started;
}

UseCase "Begin (membership) vetting ('helper approval') process" {
  /* Reference: PubSub utility appendix in PWCF */
  PubSubUtility - IProcessManager.OnMemberApplied() > ProcessManager

}


/* NOTE: When to notify different people/groups in the organization should be part of the workflow. */
Activity "Notify helper approval supervisors" {
  |System|
  start
  :Receive helper approval started;
  :Lookup helper approval supervisors;
  |Helper|
  :Notify helper approval supervisors;
}

Activity "Complete a helper approval action" {
  |Helper|
  start
  :Complete action;
  |System|
  :Record action completion;
  :Process workflow;
}




Activity "Create Referral" {
  |Client|
  start
  :Submit referral request;
  note: Referral can be linked to a client household.
  |System|
  :Validate referral request;
  if (Request valid?) then (no)
    |Client|
    :Error;
    stop
  else (yes)
    |System|
    :Create referral;
    :Determine intake steps;
    :Store intake steps;
    :Publish referral created;
    stop
  endif
}

UseCase "Create Referral" {
  @@@
  ### Actor(s)
  User identity or Organization identity.
  
  ### Operational Concept
  The system:
  1. validates the caller's account,
  2. 

  ### API
  `POST /referrals/{referralId}`
  
  ### Test Cases
  1. **Given** ...,
     **when** requesting help **then** ...
  2. **Given** the referral request is invalid,
     **when** requesting help **then** an opaque fault is returned.
  @@@
  WebAppClient - Referral SubmitRequest(ReferralRequest) > ProcessManager
  /*TODO: We may not need an engine to validate requests. */
  /*ProcessManager - void Validate(ReferralRequest) > EvaluationEngine*/
  ProcessManager - Referral CreateReferral(ReferralRequest) > RecordsAccess -> RecordsResource
  ProcessManager - IntakePolicy LookupIntakePolicy(DefaultPolicyCritera) > ConfigurationAccess -> ConfigurationResource
  /* This tags the referral with the intake policy version that was applied. */
  ProcessManager - SaveIntakeSteps(IntakeSteps) > RecordsAccess -> RecordsResource
  ProcessManager - IProcessEvent.OnReferralCreated(Referral) > PubSubUtility
}

UseCase "Custom procedure when a referral is created" {
  @@@
  This is an example of a custom procedure "hook" that the system exposes.
  @@@
  PubSubUtility - IProcessEvent.OnReferralCreated(Referral) > WorkflowUtility
}

Activity "Notify intake supervisors" {
  |System|
  start
  :Receive referral created;
  :Lookup intake supervisors;
  |Helper|
  :Notify intake supervisors;
}

UseCase "Notify intake supervisors" {
  PubSubUtility - IProcessEvent.OnReferralCreated(Referral) > CommunicationManager
  CommunicationManager - CommunicationPolicy LookupCommunicationPolicy() > ConfigurationAccess -> ConfigurationResource
  CommunicationManager - Array<Person> GetPeople(ListedPeopleCriteria) > RecordsAccess -> RecordsResource
  /* This can be email, SMS, Teams, Slack, etc. */
  /*TODO: Factor out the abstraction across all message transport types */
  CommunicationManager - Send(Message) > MessagingUtility
}

Activity "User uploads a document" {
  |Client|
  start
  :Upload document;
  |System|
  :Save document;
  :Publish document uploaded;
  stop
}

UseCase "Upload a document" {
  @@@
  ### Actor(s)
  User identity or Organization identity.
  
  ### Operational Concept
  The system:
  1. validates the caller's account,
  2. validates the user-specified access level to associate with the document,
  3. and saves the document in the specified (client, helper, etc.) record.

  ### API
  `POST /documents`
  
  ### Test Cases
  1. **Given** ...,
     **when** uploading a document **then** ...
  2. **Given** the requested access level is invalid for the user,
     **when** uploading a document **then** an opaque fault is returned.
  @@@
  WebAppClient - RecordId IProcessManager.Submit(Document) > ProcessManager
  ProcessManager - IConfigurationAccess.LookupAccessLevelPolicy() > ConfigurationAccess -> ConfigurationResource
  ProcessManager - Store(Document) > RecordsAccess -> RecordsResource
  ProcessManager - IProcessEvent.OnSubmitted(Document) > PubSubUtility
}

Activity "User enters a note" {
  |Client|
  start
  :Enter note;
  |System|
  :Save draft note;
  note: Notes always require human verification before finalizing.
  :Publish this draft note entered;
  stop
}

UseCase "Enter a note" {
  @@@
  ### Actor(s)
  User identity or Organization identity.
  
  ### Operational Concept
  The system:
  1. validates the caller's account,
  2. validates the user-specified access level to associate with the note,
  3. and saves the draft note in the specified (client, helper, etc.) record.

  ### API
  `POST /notes`
  
  ### Test Cases
  1. **Given** ...,
     **when** entering a note **then** ...
  2. **Given** the requested access level is invalid for the user,
     **when** entering a note **then** an opaque fault is returned.
  @@@
  /*BLAIR: Pressing 'Enter' after the '@@@' puts the newline on the line before the '@@@' for some reason. */
  WebAppClient - RecordId IProcessManager.Submit(Note) > ProcessManager
  ProcessManager - IConfigurationAccess.LookupAccessLevelPolicy() > ConfigurationAccess -> ConfigurationResource
  /* Legal question: Do draft notes fall under peer review privilege? If so, it's better to store the intermediate versions as well. */
  /* Aside: Customers need to indemnify CareTogether against any liability arising from their use of the software. */
  /* Desirable: Overall limitation of liability. */
  ProcessManager - StoreDraft(Note) > RecordsAccess -> RecordsResource
  ProcessManager - IProcessEvent.OnVerificationRequested(Note) > PubSubUtility
}

DTO RecordId {
  Guid Id
}
DTO AccessLevelId {
  Guid Id
}
DTO UserId {
  Guid Id
}
DTO OrganizationId {
  Guid Id
}
DTO Timestamp {
  DateTime Utc
}
DTO DateRange {
  DateOnly Start
  DateOnly End /* A DateRange can have a max-value end date. */
}

DTO /*abstract*/ Identity {}
DTO UserIdentity : Identity {
  UserId UserId
}
DTO OrganizationIdentity : Identity {
  OrganizationId OrganizationId
}

DTO /*abstract*/ IProcessManager Record {
  RecordId Id
  AccessLevelId AccessLevel
  AuditEntry[] History
}

DTO /*abstract*/ IProcessManager AuditEntry {
  Identity Identity
  Timestamp Timestamp
  IpAddress ClientIp
}
DTO IProcessManager Submitted : AuditEntry {}
DTO IProcessManager Edited : AuditEntry {}
DTO IProcessManager Feedback : AuditEntry {
  string Comment
}
DTO IProcessManager Verified : AuditEntry {}
DTO IProcessManager Listed : AuditEntry {} /* E.g., appeared in a search result */
DTO IProcessManager Retrieved : AuditEntry {}

DTO IProcessManager Note : Record {
  string Text
  DateOnly Date /* Will default to today's date */
}

DTO IProcessManager Document : Record {
  string Filename
  byte[] Contents
}

DTO IProcessManager StepCompletion : Record {
  StepId Step
  DateRange CompletedDuring
  RecordId[] LinkedNotes
  RecordId[] LinkedDocuments
}

DTO IProcessManager StepExemption : Record {
  StepId Step
  DateRange ExemptedDuring
}

Activity "User completes an abstract step" {
  |Client|
  start
  :Complete step
    (may reference a document and/or note);
  |System|
  if (Verification required?) then (yes)
    :Save this draft;
    :Publish verification request;
    stop
  else (no)
    :Record this step completion;
    :Publish this step completed;
    stop
  endif
}

UseCase "Complete a step" {
  @@@
  ### Actor(s)
  User identity or Organization identity.
  
  ### Operational Concept
  The system:
  1. validates the caller's account,
  2. validates the user-specified access level to associate with the step completion,
  3. determines whether the step completion requires verification,
     1. if so,
        1. saves this completion as a draft in the specified (client, helper, etc.) record
        2. and publishes a verification request;
     2. if not,
        1. records this completion in the specified (client, helper, etc.) record
        2. and publishes the step completion.

  ### API
  `POST /steps`
  
  ### Test Cases
  1. **Given** ...,
     **when** completing a step **then** ...
  2. **Given** the requested access level is invalid for the user,
     **when** completing a step **then** an opaque fault is returned.
  @@@
  WebAppClient - RecordId IProcessManager.Submit(StepCompletion) > ProcessManager
  ProcessManager - IConfigurationAccess.LookupAccessLevelPolicy() > ConfigurationAccess -> ConfigurationResource
  ProcessManager - IConfigurationAccess.LookupStepCompletionVerificationPolicy() > ConfigurationAccess -> ConfigurationResource
  /* See child use cases for the variation in the remainder of the logic */
}

UseCase "Complete a step - no verification required" {
  /*BLAIR: Can we write 'if' statements in here? Full pseudocode. :) */
  WebAppClient - RecordId IProcessManager.Submit(StepCompletion) > ProcessManager
  ProcessManager - IConfigurationAccess.LookupAccessLevelPolicy() > ConfigurationAccess -> ConfigurationResource
  ProcessManager - IConfigurationAccess.LookupStepCompletionVerificationPolicy() > ConfigurationAccess -> ConfigurationResource
  ProcessManager - Store(StepCompletion) > RecordsAccess -> RecordsResource
  ProcessManager - IProcessEvent.OnSubmitted(StepCompletion) > PubSubUtility
}

UseCase "Complete a step - verification required" {
  WebAppClient - RecordId IProcessManager.Submit(StepCompletion) > ProcessManager
  ProcessManager - IConfigurationAccess.LookupAccessLevelPolicy() > ConfigurationAccess -> ConfigurationResource
  ProcessManager - IConfigurationAccess.LookupStepCompletionVerificationPolicy() > ConfigurationAccess -> ConfigurationResource
  ProcessManager - StoreDraft(StepCompletion) > RecordsAccess -> RecordsResource
  ProcessManager - IProcessEvent.OnVerificationRequested(StepCompletion) > PubSubUtility
}

Activity "User searches for a record" {
  |Client|
  start
  :Provide search parameters;
  |System|
  :Search for matching records;
  stop
}

UseCase "User searches for a record" {
  @@@
  ### Actor(s)
  User identity or Organization identity.
  
  ### Operational Concept
  The system:
  1. validates the caller's account,
  2. authorizes the user's ability to verify the specified draft record,
  ...

  ### API
  ...
  
  ### Test Cases
  1. **Given** ...,
     **when** verifying a draft record **then** ...
  @@@
  WebAppClient - Array<RecordHeader> IProcessManager.Search(RecordCriteria) > ProcessManager
  ProcessManager - Array<RecordHeader> IMatchingEngine.Search(RecordCriteria) > MatchingEngine
  MatchingEngine - IRecordsAccess.FilterRecords(RecordCriteria)> RecordsAccess -> RecordsResource
  /*BLAIR: Need to pass an array as the request DTO here */
  ProcessManager - void IRecordsAccess.TrackListing(RecordHeader) > RecordsAccess -> RecordsResource
}

Activity "User looks up pending verification requests" {
  |Client|
  start
  :Look up pending verification requests;
  |System|
  :List pending verification requests for this user;
  stop
}

UseCase "User looks up pending verification requests" {
  @@@
  ### Actor(s)
  User identity only, no Organization identity.
  
  ### Operational Concept
  The system:
  1. validates the caller's account,
  2. authorizes the user's ability to verify the specified draft record,
  ...

  ### API
  ...
  
  ### Test Cases
  1. **Given** ...,
     **when** verifying a draft record **then** ...
  @@@
  /*TODO: Revise this: things I'm not happy with include:
          1. VerificationRequest feels very similar to the RecordHeader
          2. Polymorphic 'Search' with two different types of content feels wrong
          3. Search passing through to Search is at least concerning
          4. Search followed by List feels redundant */
  WebAppClient - Array<VerificationRequest> IProcessManager.Search(RequestCriteria) > ProcessManager
  ProcessManager - Array<VerificationRequest> IMatchingEngine.Search(RequestCriteria) > MatchingEngine
  MatchingEngine - IRecordsAccess.ListRecords(RequestCriteria)> RecordsAccess -> RecordsResource
  /*BLAIR: Need to pass an array as the request DTO here */
  ProcessManager - void IRecordsAccess.TrackListing(RecordHeader) > RecordsAccess -> RecordsResource
}

Activity "User reviews a record based on a search result" {
  |Client|
  start
  :Select a search result;
  |System|
  :Retrieve record;
  stop
}

Activity "User reviews a record based on a verification request" {
  |Client|
  start
  :Select verification request;
  |System|
  :Retrieve corresponding draft record;
  stop
}

UseCase "User retrieves records" {
  @@@
  ### Actor(s)
  User identity or Organization identity.
  
  ### Operational Concept
  The system:
  1. validates the caller's account,
  2. delegates to the evaluation engine the following:
     1. look up the specified records, TODO: Does authorization depend on record contents in V2?
     2. authorize the user's ability to retrieve the specified records (which may be based on record contents),
     3. disclose the records per the data disclosure policy

  ### API
  ...
  
  ### Test Cases
  1. **Given** ...,
     **when** verifying a draft record **then** ...
  @@@
  /*BLAIR: Need to pass an array as the request and response DTO here */
  WebAppClient - Array<Record> IProcessManager.Retrieve(RecordId) > ProcessManager
  /*BLAIR: Need to pass an array as the request and response DTO here */
  ProcessManager - Array<Record> IEvaluationEngine.Disclose(Record) > EvaluationEngine
  EvaluationEngine - IRecordsAccess.ListRecords(RecordId) > RecordsAccess -> RecordsResource
  EvaluationEngine - IConfigurationAccess.LoadDisclosurePolicy() > ConfigurationAccess -> ConfigurationResource
  /*BLAIR: Need to pass an array as the request DTO here */
  ProcessManager - void IRecordsAccess.TrackRetrieval(RecordId) > RecordsAccess -> RecordsResource
}

Activity "User verifies a draft record" {
  |Client|
  start
  :Verify record;
  |System|
  if (Record has pending feedback) then (yes)
    note: Post-V2, we may want to require feedback items to be addressed explicitly.
  endif
  :Store record verification;
  :Publish record verified;
  stop
}

UseCase "User verifies a draft record" {
  @@@
  ### Actor(s)
  User identity only, no Organization identity.
  
  ### Operational Concept
  The system:
  1. validates the caller's account,
  2. ...

  ### API
  ...
  
  ### Test Cases
  1. **Given** ...,
     **when** approving a draft record **then** ...
  @@@
  WebAppClient - IProcessManager.Verify(RecordHeader) > ProcessManager
  /* TODO: This should be applied at an interceptor level. */
  ProcessManager - ISecurityUtility.PreAuthorize(OrganizationAccess) > SecurityUtility
  ProcessManager - AuthorizationResult IEvaluationEngine.Authorize(RecordVerification) > EvaluationEngine
  EvaluationEngine - IConfigurationAccess.LookupVerificationPolicy() > ConfigurationAccess -> ConfigurationResource
  EvaluationEngine - Record IRecordsAccess.Filter(RecordCriteria) > RecordsAccess -> RecordsResource
  /*TODO: This feels like it needs revision */
  ProcessManager - IRecordsAccess.Verify(RecordHeader) > RecordsAccess -> RecordsResource
  ProcessManager - IProcessEvent.OnVerified(RecordHeader) > PubSubUtility
  ProcessManager - IProcessEvent.OnRejected(RecordApproval) > PubSubUtility
}

Activity "User revises a draft record" {
  |Client|
  start
  :Submit revision;
  |System|
  if (Record is already verified) then (yes)
    stop
    note: Verification is final.
  else
    :Store record revision;
    :Publish record revised;
    stop
  endif
}

UseCase "User revises a draft record" {
  @@@
  ### Actor(s)
  User identity only, no Organization identity.
  
  ### Operational Concept
  The system:
  1. validates the caller's account,
  2. ...

  ### API
  ...
  
  ### Test Cases
  1. **Given** ...,
     **when** revising a draft record **then** ...
  @@@
  WebAppClient - IProcessManager.Revise(Record) > ProcessManager
  ProcessManager - AuthorizationResult IEvaluationEngine.Authorize(RecordRevision) > EvaluationEngine
  EvaluationEngine - IConfigurationAccess.LookupRevisionPolicy() > ConfigurationAccess -> ConfigurationResource
  EvaluationEngine - Record IRecordsAccess.Filter(RecordCriteria) > RecordsAccess -> RecordsResource
  ProcessManager - IProcessEvent.OnRejected(RecordRevision) > PubSubUtility
  ProcessManager - IRecordsAccess.Store(Record) > RecordsAccess -> RecordsResource
  ProcessManager - IProcessEvent.OnRevised(Record) > PubSubUtility
}

Activity "User creates a household with first adult" {
  |Client|
  start
  :Provide information on first adult in household;
  |System|
  :Create household;
  :Create person;
  :Link person to household;
  note: Creating a household does not require verification, only authorization.
  stop
}

UseCase "User creates a household with first adult" {
  @@@
  ### Actor(s)
  User identity or Organization identity.
  
  ### Operational Concept
  The system:
  1. validates the caller's account,
  2. ...

  ### API
  ...
  
  ### Test Cases
  1. **Given** ...,
     **when** creating a household **then** ...
  @@@
  WebAppClient - IProcessManager.Submit(Household) > ProcessManager
  ProcessManager - IEvaluationEngine.Authorize(CreateHousehold) > EvaluationEngine
  EvaluationEngine - IConfigurationAccess.LoadPolicy() > ConfigurationAccess -> ConfigurationResource
  ProcessManager - IAuthorizationEvent.OnRejected(CreateHousehold) > PubSubUtility
  ProcessManager - IRecordsAccess.Store(Household) > RecordsAccess -> RecordsResource
  ProcessManager - IAuthorizationEvent.OnApproved(CreateHousehold) > PubSubUtility
}

DTO IProcessManager Household {
  Person[] People
}

DTO IProcessManager Person {}

Activity "User adds a person to a household" {
  note: A person can be an adult or a child.
  |Client|
  start
  :Select household;
  :Provide information on person to add;
  |System|
  :Create person;
  :Link person to household;
  stop
}

Activity "User links a referral to a household" {
  note: This implicitly designates the household as a client household.
  |Client|
  start
  :Select referral;
  :Select household to link to referral as client;
  |System|
  :Link household to referral;
  :Publish referral linked to household;
  stop
}

Activity "User opens a case from a referral" {
  |Client|
  start
  :Select referral;
  :Open case;
  |System|
  :Open a case, linked to the referral;
  :Publish case opened;
  stop
}

Activity "User closes a referral" {
  |Client|
  start
  :Select referral;
  :Provide referral close reason;
  |System|
  :Close referral with specified reason;
  :Publish referral closed;
  stop
}

/*TODO: We need a 'garbage collector'/timer/similar to automatically, reliably,
        flag records that are no longer completed or no longer exempted, and
        update the containing record's state -- the associated step needs to be
        treated as incomplete and the appropriate users need to be notified.
        HOWEVER, this is also something we will want to do *ahead of time*, not
        just at/after the expiration, so that users can have a heads-up of a
        pending expiration. The general term for this is a "recertification" or
        "renewal", aka a "grace period" if it is after the fact.
        For now, we will approach this from the 'heads-up' point of view. */




/*
Activity "Configure Intake Supervisor" {
  |Helper|
  start
  :Subscribe to 'intake started';
}*/


/*SYMMETRY: Requests --> Processes --> Actions */

Activity "Onboard a New Member" {}



Activity "Open Case" {}

Activity "Close Case" {}



Activity "Set Up Arrangement" {}

Activity "Complete Setup Action" {}

Activity "Cancel Arrangement" {}

Activity "Start Arrangement" {}

Activity "Monitor Arrangement" {} /* TODO: Not sure about naming here */

Activity "Complete Monitoring Action" {}

Activity "Track Child Location" {} /* *VERY* specific element in the domain, not fractal-friendly */
/* We can imagine that other human services categories will have other domain-specific "things",
   e.g. Track Occupancy in transitional living --- this feels like 'industry' context? */

Activity "Close Out Arrangement" {}

Activity "Complete Closeout Action" {}

Activity "Follow Up With Client" {}





Activity "Help Client" {}
Activity "Apply to Help" {}
Activity "Recruit Helpers" {}
Activity "Helper Approval" {}
Activity "Establish Referral Partner" {}
Activity "Make Outbound Referral" {}
Activity "Assess Impact" {}

Activity "Client Referral Intake" {
  start
  stop
}






/* NOTE: The following are *operations* -- activities */
Activity "Submit Records" {} /* Core use case; includes archiving records, managing user roles */
Activity "Retrieve Records" {} /* Core use case */

Activity "Approve Records Submission" {}
Activity "Reject Records Submission" {}
Activity "Approve Records Retrieval" {}
Activity "Reject Records Retrieval" {}

Activity "Download Document" {}
Activity "Upload Document" {}

/* Post-2025/2026 */
/* There may be a fractal here? */
Activity "Accept Inbound Referral" {}
Activity "Submit Outbound Referral" {}

/* Facet: Personal Records */
/* Is a household an organization if we squint enough? Maybe. */
/* Is an organization a person, if we squint enough? Maybe. */
Activity "Upload Requested Documentation" {}
Activity "Generate Assertions" {}
Activity "Share Assertions" {}
Activity "Audit Assertions" {}

|
| "Core Use Case: Communication"
/* For symmetry: organization & personal facets? */
/*TODO: This section still needs to be cleaned up */

Activity "Notify Organization" {}

Activity "Send Bulk SMS" {} /* This is a primitive action */
Activity "Volunteer Search" {} /* This is a -- very complicated -- workflow */
Activity "Communication Tree" {} /* This is a workflow */
Activity "Notify Person" {}
Activity "Broadcast" {} /* to an audience */
Activity "Receive Response" {} /* this is a placeholder */
Activity "Notify of Record Changes" {} /*TODO: Revisit what this part of the domain looks like abstractly */


|
| "Reference --- other services' responsibilities"

Activity "Query Permissions" {} /* Feels like an evaluation activity */
Activity "Calculate Approval Status" {} /* Feels like an evaluation activity */
Activity "Calculate Pending Steps" {} /* Feels like an evaluation activity */


|
| "Volatilities"

UseCase Volatilities {
@@@
## Volatilities

- XYZ
@@@
}


|
| "Static Aspect"
StaticAspect "CareTogether V2" {
  WebAppClient SupportClient SdkClient
  /* GraphQL/HTTP API layer */
  ProcessManager CommunicationManager AnalysisManager
  EvaluationEngine MatchingEngine
  NetworkAccess ConfigurationAccess RecordsAccess
  /*NOTE: NetworkResource? -- Cosmos DB Graph API & Cosmos DB 'SQL' API, allowing Geode pattern. */
  NetworkResource
  /*NOTE: Configuration includes the DSL 'procedures' which can be *compiled* into workflows. */
  ConfigurationResource:f
  /*NOTE: Audit logs are an aspect of record-keeping. */
  /* Notes are part of RecordsResource but stored w/ immutability enabled.
     Forms are part of RecordsResource. */
  RecordsResource
  SecurityUtility /* Includes account management operations */
  TelemetryUtility
  LoggingUtility
  PubSubUtility /* Push notifications to WebApp are allowed, as queued calls; can include delivery via SMS, WhatsApp, Telegram, Teams, Slack, etc. */
  /* User will subscribe to pub-sub endpoints; the CommunicationManager will generate channel-specific events in response to domain events */
  WorkflowUtility
  MessagingUtility
}


|