/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class ClaimsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<string[]> {
        let url_ = this.baseUrl + "/Claims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }
}

export class PeopleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(organizationId: string, locationId: string): Promise<Person[]> {
        let url_ = this.baseUrl + "/api/{organizationId}/{locationId}/People";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (locationId === undefined || locationId === null)
            throw new Error("The parameter 'locationId' must be defined.");
        url_ = url_.replace("{locationId}", encodeURIComponent("" + locationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Person[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Person.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Person[]>(<any>null);
    }

    getContactInfo(organizationId: string, locationId: string, personId: string): Promise<PersonDetails> {
        let url_ = this.baseUrl + "/api/{organizationId}/{locationId}/People/{personId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (locationId === undefined || locationId === null)
            throw new Error("The parameter 'locationId' must be defined.");
        url_ = url_.replace("{locationId}", encodeURIComponent("" + locationId));
        if (personId === undefined || personId === null)
            throw new Error("The parameter 'personId' must be defined.");
        url_ = url_.replace("{personId}", encodeURIComponent("" + personId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContactInfo(_response);
        });
    }

    protected processGetContactInfo(response: Response): Promise<PersonDetails> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonDetails.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersonDetails>(<any>null);
    }
}

export class Person implements IPerson {
    id?: string;
    userId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    age?: Age | undefined;

    constructor(data?: IPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.age = _data["age"] ? Age.fromJS(_data["age"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Person {
        data = typeof data === 'object' ? data : {};
        let result = new Person();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["age"] = this.age ? this.age.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPerson {
    id?: string;
    userId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    age?: Age | undefined;
}

export abstract class Age implements IAge {
    type?: AgeType;

    constructor(data?: IAge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Age {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Age' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        return data; 
    }
}

export interface IAge {
    type?: AgeType;
}

export enum AgeType {
    AgeInYears = 0,
    ExactAge = 1,
}

export class PersonDetails implements IPersonDetails {
    person?: Person | undefined;
    contactInfo?: ContactInfo | undefined;

    constructor(data?: IPersonDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>undefined;
            this.contactInfo = _data["contactInfo"] ? ContactInfo.fromJS(_data["contactInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PersonDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PersonDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["contactInfo"] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPersonDetails {
    person?: Person | undefined;
    contactInfo?: ContactInfo | undefined;
}

export class ContactInfo implements IContactInfo {
    personId?: string;
    addresses?: Address[] | undefined;
    currentAddressId?: string | undefined;
    phoneNumbers?: PhoneNumber[] | undefined;
    preferredPhoneNumberId?: string | undefined;
    emailAddresses?: EmailAddress[] | undefined;
    preferredEmailAddressId?: string | undefined;
    contactMethodPreferenceNotes?: string | undefined;

    constructor(data?: IContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personId = _data["personId"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(Address.fromJS(item));
            }
            this.currentAddressId = _data["currentAddressId"];
            if (Array.isArray(_data["phoneNumbers"])) {
                this.phoneNumbers = [] as any;
                for (let item of _data["phoneNumbers"])
                    this.phoneNumbers!.push(PhoneNumber.fromJS(item));
            }
            this.preferredPhoneNumberId = _data["preferredPhoneNumberId"];
            if (Array.isArray(_data["emailAddresses"])) {
                this.emailAddresses = [] as any;
                for (let item of _data["emailAddresses"])
                    this.emailAddresses!.push(EmailAddress.fromJS(item));
            }
            this.preferredEmailAddressId = _data["preferredEmailAddressId"];
            this.contactMethodPreferenceNotes = _data["contactMethodPreferenceNotes"];
        }
    }

    static fromJS(data: any): ContactInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        data["currentAddressId"] = this.currentAddressId;
        if (Array.isArray(this.phoneNumbers)) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item.toJSON());
        }
        data["preferredPhoneNumberId"] = this.preferredPhoneNumberId;
        if (Array.isArray(this.emailAddresses)) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item.toJSON());
        }
        data["preferredEmailAddressId"] = this.preferredEmailAddressId;
        data["contactMethodPreferenceNotes"] = this.contactMethodPreferenceNotes;
        return data; 
    }
}

export interface IContactInfo {
    personId?: string;
    addresses?: Address[] | undefined;
    currentAddressId?: string | undefined;
    phoneNumbers?: PhoneNumber[] | undefined;
    preferredPhoneNumberId?: string | undefined;
    emailAddresses?: EmailAddress[] | undefined;
    preferredEmailAddressId?: string | undefined;
    contactMethodPreferenceNotes?: string | undefined;
}

export class Address implements IAddress {
    id?: string;
    line1?: string | undefined;
    line2?: string | undefined;
    city?: string | undefined;
    stateId?: string;
    postalCode?: string | undefined;
    countryId?: string;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.city = _data["city"];
            this.stateId = _data["stateId"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export interface IAddress {
    id?: string;
    line1?: string | undefined;
    line2?: string | undefined;
    city?: string | undefined;
    stateId?: string;
    postalCode?: string | undefined;
    countryId?: string;
}

export class PhoneNumber implements IPhoneNumber {
    id?: string;
    number?: string | undefined;
    type?: PhoneNumberType;

    constructor(data?: IPhoneNumber) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): PhoneNumber {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumber();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["type"] = this.type;
        return data; 
    }
}

export interface IPhoneNumber {
    id?: string;
    number?: string | undefined;
    type?: PhoneNumberType;
}

export enum PhoneNumberType {
    Mobile = 0,
    Home = 1,
    Work = 2,
    Fax = 3,
}

export class EmailAddress implements IEmailAddress {
    id?: string;
    address?: string | undefined;
    type?: EmailAddressType;

    constructor(data?: IEmailAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.address = _data["address"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): EmailAddress {
        data = typeof data === 'object' ? data : {};
        let result = new EmailAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["address"] = this.address;
        data["type"] = this.type;
        return data; 
    }
}

export interface IEmailAddress {
    id?: string;
    address?: string | undefined;
    type?: EmailAddressType;
}

export enum EmailAddressType {
    Personal = 0,
    Work = 1,
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}